<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Leaflet: Dynamic Spawn Types</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }
    /* Error messages container */
    #error { 
      color: red; 
      padding: 10px; 
      font-family: sans-serif; 
      position: absolute; 
      z-index: 1000; 
      background: rgba(255,255,255,0.8); 
      max-width: 300px; 
      top: 0;
      left: 0;
    }

    /* Blinking Player Marker */
    .blinking-circle {
      width: 15px;
      height: 15px;
      background: rgba(0, 0, 255, 0.8);
      border: 2px solid white;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Blinking Public Event Zone */
    .blinking-zone {
      animation: blinkZone 2s infinite;
    }
    @keyframes blinkZone {
      0% { fill-opacity: 0.1; }
      50% { fill-opacity: 0.05; }
      100% { fill-opacity: 0.1; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="error"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

  <script>
    const spawnDataUrl = "https://raw.githubusercontent.com/black6ja/WanderingLegends/main/spawnData.json";
    const PUBLIC_EVENT_RADIUS = 300; // Radius only for public event zones

    var lastPlayerLatLng = null;
    var spawnTypes = null;
    var markersCluster = L.markerClusterGroup();
    var initialCentered = false;
    var dynamicSpawnPoints = [];

    // Use default location if geolocation fails.
    const DEFAULT_LOCATION = { lat: 51.505, lng: -0.09 };

    var map = L.map('map', { preferCanvas: true, zoomAnimation: true }).setView([DEFAULT_LOCATION.lat, DEFAULT_LOCATION.lng], 15);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Blinking Player Marker
    var playerMarker = L.marker([DEFAULT_LOCATION.lat, DEFAULT_LOCATION.lng], {
      icon: L.divIcon({ className: '', html: '<div class="blinking-circle"></div>', iconSize: [15, 15], iconAnchor: [7, 7] })
    });

    // Player Radius (soft blue circle)
    var playerRadiusCircle = L.circle([DEFAULT_LOCATION.lat, DEFAULT_LOCATION.lng], {
      color: 'blue',
      fillColor: 'rgba(0, 0, 255, 0.3)',
      fillOpacity: 0.3,
      radius: 229
    });

    function pickSpawnType() {
      if (!spawnTypes || !Array.isArray(spawnTypes) || spawnTypes.length === 0) return null;
      
      var totalRate = spawnTypes.reduce((acc, st) => acc + (st.spawnRate || 0), 0);
      var rnd = Math.random() * totalRate;
      var cumulative = 0;
      
      for (var i = 0; i < spawnTypes.length; i++) {
        cumulative += spawnTypes[i].spawnRate || 0;
        if (rnd <= cumulative) return spawnTypes[i];
      }
      
      return spawnTypes[spawnTypes.length - 1];
    }

    // Fixed isSpawnAllowed function
    function isSpawnAllowed(type, lat, lng) {
      let restrictions = spawnTypes.find(s => s.type === type)?.restrictions;
      if (!restrictions || !restrictions.minDistanceFrom) return true;
      
      return !dynamicSpawnPoints.some(existing => {
        let minDistance = restrictions.minDistanceFrom[existing.type];
        // If there's no restriction for this combination, return false (doesn't violate)
        if (!minDistance) return false;
        
        try {
          // Check if our new point is too close (violates restriction)
          return map.distance([lat, lng], [existing.lat, existing.lng]) < minDistance;
        } catch (e) {
          console.error("Error calculating distance:", e);
          return true; // Be conservative and assume restriction is violated
        }
      });
    }

    // Improved dynamic spawn generation
    function generateDynamicSpawns(center) {
      dynamicSpawnPoints = [];
      // Group spawns by type to ensure variety
      const maxSpawnsByType = {
        "creatures": 5,
        "dungeons": 2,
        "inns": 3,
        "shops": 3,
        "quests": 4,
        "keeps": 1,
        "lairs": 2,
        "publicEvent": 1
      };
      
      const spawnsByType = {};
      
      // Generate varied spawn types
      for (let i = 0; i < 15; i++) {
        const st = pickSpawnType();
        if (!st) continue;
        
        // Initialize counter if needed
        if (!spawnsByType[st.type]) spawnsByType[st.type] = 0;
        
        // Check if we've reached the max for this type
        if (spawnsByType[st.type] >= (maxSpawnsByType[st.type] || 3)) continue;
        
        // Generate position
        const r = 250 + Math.random() * 500;
        const angle = Math.random() * 2 * Math.PI;
        const dLat = r / 111300 * Math.cos(angle);
        const dLng = r / (111300 * Math.cos(center.lat * Math.PI / 180)) * Math.sin(angle);
        const lat = center.lat + dLat;
        const lng = center.lng + dLng;
        
        // Check if spawn is allowed at this position
        if (isSpawnAllowed(st.type, lat, lng)) {
          // Only add radius for public events
          dynamicSpawnPoints.push({ 
            type: st.type, 
            lat: lat, 
            lng: lng, 
            radius: st.type === "publicEvent" ? PUBLIC_EVENT_RADIUS : null 
          });
          spawnsByType[st.type]++;
        }
      }
    }

    function generateIrregularPolygon(center, baseRadius) {
      var numPoints = 8 + Math.floor(Math.random() * 4); // 8-12 points
      var points = [];
      for (var i = 0; i < numPoints; i++) {
        var angle = (2 * Math.PI / numPoints) * i + (Math.random() * 0.4 - 0.2); // add slight randomness
        var factor = 0.6 + Math.random() * 0.8; // factor between 0.6 and 1.4
        var r = baseRadius * factor;
        var latOffset = (r * Math.cos(angle)) / 111300;
        var lngOffset = (r * Math.sin(angle)) / (111300 * Math.cos(center.lat * Math.PI / 180));
        points.push([center.lat + latOffset, center.lng + lngOffset]);
      }
      return points;
    }

    function updateVisibleSpawns() {
      markersCluster.clearLayers();
      var bounds = map.getBounds();

      dynamicSpawnPoints.forEach((spawn) => {
        var pt = L.latLng(spawn.lat, spawn.lng);
        if (spawn.type === "publicEvent" && spawn.radius) {
          var polygonCoords = generateIrregularPolygon(pt, spawn.radius);
          L.polygon(polygonCoords, {
            color: "red",
            fillColor: "red",
            fillOpacity: 0.1, // 90% transparent
            weight: 2,
            className: "blinking-zone"
          }).bindPopup("Public Event Zone").addTo(map);
        } else if (bounds.contains(pt)) {
          var marker = L.circleMarker(pt, {
            color: getSpawnColor(spawn.type),
            fillColor: getSpawnColor(spawn.type),
            fillOpacity: 0.7,
            radius: 7
          }).bindPopup(`Spawn: ${spawn.type}`);
          markersCluster.addLayer(marker);
        }
      });

      if (!map.hasLayer(markersCluster)) map.addLayer(markersCluster);
    }

    function getSpawnColor(type) {
      const colors = {
        "creatures": "purple",
        "dungeons": "gray",
        "inns": "orange",
        "shops": "blue",
        "quests": "green",
        "keeps": "brown",
        "lairs": "black"
      };
      return colors[type] || "red";
    }

    // Geolocation event: location found with initial centering
    map.on('locationfound', function(e) {
      lastPlayerLatLng = e.latlng;
      
      // Update player marker and radius
      if (!map.hasLayer(playerMarker)) {
        playerMarker.addTo(map);
        playerRadiusCircle.addTo(map);
      }
      
      playerMarker.setLatLng(e.latlng);
      playerRadiusCircle.setLatLng(e.latlng);
      
      // Center map on first location found
      if (!initialCentered) {
        map.setView(e.latlng, 15);
        initialCentered = true;
      }
      
      generateDynamicSpawns(e.latlng);
      updateVisibleSpawns();
    });

    // Add movement update handler
    map.on('locationupdate', function(e) {
      if (!lastPlayerLatLng) return;
      
      const newLatLng = e.latlng;
      playerMarker.setLatLng(newLatLng);
      playerRadiusCircle.setLatLng(newLatLng);
      
      // Re-generate spawns if moved significantly
      try {
        if (map.distance(newLatLng, lastPlayerLatLng) > 100) {
          generateDynamicSpawns(newLatLng);
          lastPlayerLatLng = newLatLng;
        }
      } catch (error) {
        console.error("Error calculating distance:", error);
        // Fallback to simply updating position
        lastPlayerLatLng = newLatLng;
      }
      
      updateVisibleSpawns();
    });

    // Geolocation event: error
    map.on('locationerror', function(e) {
      var errorDiv = document.getElementById("error");
      errorDiv.innerHTML += `<p>Error locating user: ${e.message}</p>`;
      lastPlayerLatLng = DEFAULT_LOCATION;
      
      // Center map on default location if not centered yet
      if (!initialCentered) {
        map.setView([DEFAULT_LOCATION.lat, DEFAULT_LOCATION.lng], 15);
        initialCentered = true;
      }
      
      generateDynamicSpawns(DEFAULT_LOCATION);
      updateVisibleSpawns();
    });

    // Load spawn types from JSON and start locating
    fetch(spawnDataUrl)
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`HTTP error! Status: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        spawnTypes = data.spawnTypes || [];
        console.log(`Loaded ${spawnTypes.length} spawn types`);
        map.locate({ setView: false, watch: true, maxZoom: 16 });
      })
      .catch(err => {
        var errorDiv = document.getElementById("error");
        errorDiv.innerHTML += `<p>Error loading spawn data: ${err.message}</p>`;
        console.error("Error loading spawn data:", err);
        // Still try to locate even if spawn data fails
        map.locate({ setView: true, watch: true, maxZoom: 16 });
      });
  </script>
</body>
</html>
