html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WanderingLegends</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      position: relative;
      background-color: #f4f4f4; /* Base background */
    }
    /* Login Screen */
    #login-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f4f4f4;
    }
    #login-container button {
      padding: 10px;
      margin: 10px;
      width: 80%;
      max-width: 300px;
      background-color: #4285F4;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 1em;
    }
    #login-container button:hover { background-color: #357ae8; }
    #login-container p { font-size: 0.9em; margin-top: 10px; }

    /* Character Selection/Creation Screens */
    .screen {
      display: none; /* Hidden by default */
      padding: 20px;
      text-align: center;
      background: #fff;
      position: fixed; /* Use fixed to overlay */
      top: 0; left: 0; right: 0; bottom: 0;
      overflow-y: auto;
      z-index: 500; /* Below map but above body */
    }
    .screen.visible { display: block; } /* Show when visible */

    .class-options {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      margin: 20px 0;
    }
    .class-option {
      width: 140px;
      padding: 10px;
      margin: 10px;
      border: 2px solid #ccc;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .class-option:hover { transform: scale(1.05); }
    .class-option.selected { border-color: #FFD700; }
    .class-option img {
      width: 100%;
      height: auto;
      border-radius: 5px;
    }
    input[type="text"] {
      padding: 8px;
      margin: 10px 0;
      width: 80%;
      max-width: 300px;
    }

    /* Game UI */
    #map-container {
      display: none; /* Hidden until login/char select complete */
      flex: 1;
      position: relative; /* Needed for overlaying elements */
      width: 100%;
      height: 100vh;
    }
    #map {
      width: 100%;
      height: 100%; /* Fill container */
      min-height: 400px;
    }

    /* Debug Panel */
    #debugPanel {
      display: none; /* Hidden by default, shown if needed */
      position: fixed;
      bottom: 60px; /* Above bottom menu */
      left: 0;
      right: 0;
      background: rgba(51, 51, 51, 0.9);
      color: #fff;
      font-size: 0.8em;
      padding: 5px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 1500; /* Above map, below overlays */
    }
     /* #debugPanel.visible { display: block; } */ /* Control visibility via JS */


    /* Blinking Player Marker */
    .blinking-dot {
      width: 15px;
      height: 15px;
      background: rgba(0,0,255,0.8);
      border: 2px solid white;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* --- OVERLAY STYLES --- */

    /* General Overlay */
    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.65);
      display: flex; /* Use flex for centering */
      align-items: center;
      justify-content: center;
      z-index: 2100; /* High z-index */
    }
    .hidden {
      display: none !important; /* Use !important to ensure override if needed */
    }
    .overlay.hidden {
      display: none !important;
    }

    /* Creature Card */
    .creature-card {
      position: relative; /* Change from fixed for flex centering */
      /* top: 50px; */ /* Remove fixed positioning */
      /* left: 50%; */
      /* transform: translateX(-50%); */ /* Remove fixed positioning */
      width: 90%;
      max-width: 340px;
      background: linear-gradient(135deg, rgba(50, 50, 50, 0.95), rgba(10, 10, 10, 0.98));
      color: #f8f8f2;
      border-radius: 15px;
      border: 2px solid #FFD700; /* Default gold border */
      box-shadow: 0 0 20px gold; /* Default gold glow */
      z-index: 2000; /* Keep high */
      font-family: 'Cinzel', serif;
    }
    .card-top-corners { position: relative; width: 100%; height: 0; }
    .card-cr, .card-exp {
      position: absolute;
      width: 50px; height: 50px; line-height: 50px;
      font-size: 1.3em;
      /* rest is same */
      text-align: center; border-radius: 50%; color: #fff; background: radial-gradient(circle, #444 0%, #222 100%);
    }
    .card-cr { border: 2px solid #FFD700; top: 0; left: 0; transform: translate(-40%, -40%); }
    .card-exp { border: 2px solid #C0C0C0; top: 0; right: 0; transform: translate(40%, -40%); }
    .card-top {
      background: rgba(0, 0, 0, 0.7); width: 100%; padding: 25px 10px 10px; text-align: center;
      box-sizing: border-box; border-top-left-radius: 13px; border-top-right-radius: 13px; /* Adjust for border */
    }
    #card-name { margin: 0; font-size: 1.6em; color: #FFD700; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8); }
    .card-image-container { width: 100%; line-height: 0; } /* Remove extra space */
    #card-image { width: 100%; height: auto; object-fit: cover; }
    .card-bottom { display: flex; width: 100%; border-bottom-left-radius: 13px; border-bottom-right-radius: 13px; overflow: hidden; margin-top: 0; } /* No margin needed */
    .card-bottom button { flex: 1; font-size: 1.1em; border: none; cursor: pointer; margin: 0; padding: 12px 10px; font-family: 'Cinzel', serif; }
    #attack-button { background-color: #cc0000; color: #fff; }
    #attack-button:hover { background-color: #b30000; }
    #run-button { background-color: #1E90FF; color: #fff; }
    #run-button:hover { background-color: #187bcd; }

    /* Character Card */
    .character-card.video-game-theme {
      position: relative; /* Change from fixed for flex centering */
      background: #1d1f21;
      border: 3px solid #000000;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      padding: 20px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.8);
      color: #f1f1f1;
      font-family: 'Cinzel', serif;
      animation: fadeInScale 0.3s ease-out;
    }
    @keyframes fadeInScale { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    .card-top-row { display: flex; gap: 15px; margin-bottom: 15px; }
    .portrait-section img { width: 100px; height: 100px; object-fit: cover; border-radius: 6px; }
    .basic-info { display: flex; flex-direction: column; justify-content: center; }
    .basic-info h2 { margin: 0; font-size: 1.6em; color: #FFD700; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); }
    .basic-info p { margin: 4px 0; font-size: 1em; color: #ccc; }
    .level-xp-row { font-size: 0.9em; margin-bottom: 4px; display: flex; align-items: center; gap: 5px; }
    .level-label, .xp-label { font-weight: bold; color: #aaa; }
    .hp-ac-row { display: flex; gap: 20px; justify-content: center; margin-bottom: 20px; }
    .icon-stat { display: flex; align-items: center; gap: 8px; font-size: 1.2em; }
    .stat-icon { width: 24px; height: 24px; }
    .stat-section { margin-bottom: 20px; }
    .stat-section h3 { margin: 0 0 10px; font-size: 1.1em; color: #FFD700; text-transform: uppercase; border-bottom: 1px solid #444; padding-bottom: 5px; }
    .stat-subrow { display: flex; justify-content: space-between; font-size: 0.95em; margin-top: 5px; }
    .card-actions { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; }
    .card-actions button { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #FFD700; color: #1d1f21; font-weight: bold; cursor: pointer; transition: background 0.2s ease; }
    .card-actions button:hover { background: #e6c200; }

    /* Inventory Card */
    .inventory-card {
       position: relative; /* Change from fixed */
       width: 95%;
       max-width: 600px; /* Limit max width */
       height: 85vh; /* Limit height */
       max-height: 700px;
       background: #1d1f21;
       border: 2px solid #FFD700; /* Add border */
       border-radius: 12px; /* Rounded corners */
       padding: 15px;
       box-shadow: 0 8px 20px rgba(0, 0, 0, 0.8);
       color: #f1f1f1;
       font-family: 'Cinzel', serif;
       z-index: 2100;
       overflow-y: auto;
       overflow-x: hidden;
       box-sizing: border-box;
       display: flex; /* Use flex for layout */
       flex-direction: column;
    }
    .inventory-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #444; }
    .inventory-header h2 { margin: 0; color: #FFD700; }
    .inventory-header button { background: #555; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
    .inventory-header button:hover { background: #777; }
    .inventory-section { margin-bottom: 15px; }
    .inventory-section h3 { margin: 0 0 10px 0; color: #FFD700; border-bottom: 1px solid #444; padding-bottom: 5px; font-size: 1.1em; }
    .equipment-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
    .bag-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); flex-grow: 1; /* Allow bag grid to take space */ overflow-y: auto; /* Scroll within bag if needed */ padding: 5px; background: rgba(0,0,0,0.2); border-radius: 4px; }
    .slot, .bag-slot { border: 1px solid #555; border-radius: 6px; padding: 5px; text-align: center; min-height: 65px; font-size: 0.75em; word-wrap: break-word; overflow-wrap: break-word; background-color: #2a2a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
    .slot img, .bag-slot img { max-width: 80%; height: auto; margin-bottom: 3px; }
    .slot:hover, .bag-slot:hover { background-color: rgba(255, 215, 0, 0.1); border-color: #FFD700; }
    .dragging { opacity: 0.5; transform: scale(0.95); }
    .drag-hover { background-color: rgba(255, 215, 0, 0.25); outline: 2px dashed #FFD700; }
    .slot img, .bag-slot img { pointer-events: none; }
    .slot-header { font-size: 0.7em; font-weight: bold; color: #aaa; margin-bottom: 4px; text-align: center; }


    /* Item Card */
    .item-card {
      position: relative; /* Changed */
      width: 90%; max-width: 380px;
      height: auto; max-height: 90vh; /* Limit height */
      background: #1d1f21;
      border-radius: 12px; border: 2px solid gold; /* Add border */
      padding: 20px;
      box-shadow: 0 0 20px gold;
      color: #f1f1f1;
      font-family: 'Cinzel', serif;
      z-index: 2200;
      overflow-y: auto;
      box-sizing: border-box;
    }
    .item-card-header { text-align: center; margin-bottom: 15px; }
    .item-card-header h2 { margin: 0; font-size: 1.6em; color: #FFD700; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8); }
    .item-card-body img { display: block; margin: 0 auto 15px auto; max-width: 60%; height: auto; object-fit: contain; border-radius: 8px; background: rgba(0,0,0,0.3); padding: 5px; }
    .item-card-body p { margin: 5px 0; font-size: 0.9em; }
    .item-card-stats { margin-top: 10px; border-top: 1px solid #444; padding-top: 10px; }
    .item-card-row { margin: 6px 0; display: flex; align-items: center; font-size: 0.9em; }
    .gold-icon { margin-right: 5px; font-size: 1.1em; color: gold; }
    .item-card-description { font-style: italic; margin-top: 15px; color: #ccc; font-size: 0.85em; border-top: 1px solid #444; padding-top: 10px; }
    .item-card-specialAbilities { margin-top: 10px; padding: 10px; border: 1px dashed #FFD700; background: rgba(255, 215, 0, 0.05); border-radius: 4px; }
    .item-card-specialAbilities h3 { margin: 0 0 5px 0; font-size: 1em; color: #FFD700; }
    .item-card-specialAbilities ul { list-style: disc; padding-left: 20px; margin: 5px 0; font-size: 0.85em; }
    .item-card-actions { display: flex; justify-content: center; margin-top: 20px; }
    .item-card-actions button { padding: 10px 20px; font-size: 1em; background: #FFD700; border: none; border-radius: 5px; cursor: pointer; transition: background 0.2s ease; color: #1d1f21; font-family: 'Cinzel', serif; font-weight: bold; }
    .item-card-actions button:hover { background: #e6c200; }


    /* --- Modern Battle Card Styles --- */
    .modern-battle {
      display: flex; /* Keep flex for overall layout */
      flex-direction: column;
      height: 100%; width: 100%;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      color: #e0e0e0;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      padding: 0;
      overflow: hidden; /* Prevent scrolling */
      position: fixed; /* Ensure it overlays map */
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 3000; /* Highest */
    }
    /* Ensure .hidden works correctly */
    .modern-battle.hidden { display: none !important; }

    .combat-section { padding: 8px 12px; } /* Slightly less padding */
    .combatant-info { display: flex; align-items: center; gap: 12px; margin-bottom: 6px; }
    .player-section .combatant-info { flex-direction: row-reverse; }
    .combatant-portrait { width: 60px; height: 60px; object-fit: cover; border-radius: 6px; border: 2px solid #4a4a6a; background-color: #333; flex-shrink: 0; }
    .details { flex: 1; text-align: left; min-width: 0; /* Prevent overflow */ }
    .player-section .details { text-align: right; }
    .details h4 { margin: 0 0 3px 0; font-size: 1em; font-weight: bold; color: #FFD700; font-family: 'Cinzel', serif; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .details p { margin: 0 0 4px 0; font-size: 0.75em; color: #aaa; }
    .stats-row { font-size: 0.8em; color: #ccc; display: flex; gap: 12px; margin-top: 2px; }
    .player-section .stats-row { justify-content: flex-end; }
    .dr-row { color: #a0c0ff; font-size: 0.75em; } /* Smaller DR */
    .hp-bar-container { width: 100%; margin-bottom: 6px; }
    .hp-bar { background-color: #444; border-radius: 5px; height: 18px; position: relative; overflow: hidden; border: 1px solid #222; }
    .hp-fill { background-color: #28a745; height: 100%; width: 100%; border-radius: 4px; transition: width 0.5s ease-in-out; position: absolute; left: 0; top: 0; }
    .enemy-hp-bar .hp-fill { background-color: #dc3545; }
    .hp-text { position: absolute; width: 100%; text-align: center; color: white; font-size: 0.75em; font-weight: bold; line-height: 18px; text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8); z-index: 1; }
    .status-effects { min-height: 20px; display: flex; gap: 4px; margin-bottom: 4px; flex-wrap: wrap; } /* Wrap statuses */
    .player-section .status-effects { justify-content: flex-end; }
    .combat-log-area { flex: 1; background-color: rgba(0, 0, 0, 0.4); margin: 4px 0; padding: 6px; border-radius: 5px; overflow-y: auto; border: 1px solid rgba(255, 215, 0, 0.2); }
    #combat-log-list { list-style: none; padding: 0; margin: 0; font-size: 0.8em; color: #ddd; }
    #combat-log-list li { padding: 2px 0; border-bottom: 1px dashed rgba(255, 255, 255, 0.1); }
    #combat-log-list li:last-child { border-bottom: none; }
    .action-bar { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; padding: 8px 12px; background-color: rgba(0, 0, 0, 0.3); }
    .action-button { padding: 10px 5px; font-size: 0.85em; font-weight: bold; border: none; border-radius: 5px; cursor: pointer; color: #fff; transition: background-color 0.2s ease, transform 0.1s ease; }
    .action-button:disabled { background-color: #555 !important; color: #999; cursor: not-allowed; opacity: 0.7; }
    .action-button:not(:disabled):active { transform: scale(0.96); }
    .attack-btn { background-color: #c0392b; } .attack-btn:not(:disabled):hover { background-color: #e74c3c; }
    .special-btn { background-color: #2980b9; } .special-btn:not(:disabled):hover { background-color: #3498db; }
    .item-btn { background-color: #27ae60; } .item-btn:not(:disabled):hover { background-color: #2ecc71; }
    .end-btn { background-color: #7f8c8d; } .end-btn:not(:disabled):hover { background-color: #95a5a6; }
    .turn-order-overlay { position: absolute; top: 50%; left: 5px; transform: translateY(-50%); background: rgba(0,0,0,0.6); padding: 4px; border-radius: 6px; z-index: 10; writing-mode: vertical-lr; text-orientation: mixed; max-height: 60%; overflow: hidden; }
    .turn-order-overlay .turn-item { display: block; padding: 3px 1px; color: #ccc; font-size: 0.7em; text-align: center; border-bottom: 1px solid #444; white-space: nowrap; }
    .turn-order-overlay .turn-item:last-child { border-bottom: none; }
    .turn-order-overlay .turn-item.active { color: #FFD700; font-weight: bold; }
    .combat-section.active { /* Simplified highlight */ outline: 2px solid #FFD700; outline-offset: -2px; box-shadow: 0 0 10px #FFD700 inset; }


    /* Bottom menu bar */
    #bottom-menu {
      display: none; /* Hide until game loads */
      position: fixed; bottom: 0; left: 0; right: 0;
      height: 60px; background-color: #222; color: #fff;
      display: flex; /* Use Flexbox */ justify-content: space-around; align-items: center;
      z-index: 1000; padding: 0 10px; /* Reduce padding */
    }
     #bottom-menu.visible { display: flex; } /* Control visibility */
    #bottom-menu button { background: transparent; border: none; color: #fff; font-size: 0.9em; cursor: pointer; padding: 10px 5px; }
    #portrait-container { position: relative; width: 70px; height: 70px; } /* Smaller */
    #character-portrait { position: absolute; top: -35px; left: 50%; transform: translateX(-50%); width: 70px; height: 70px; object-fit: cover; border-radius: 50%; border: 3px solid #444; }

    /* Other UI cleanup */
     #queueStatus { display: none; } /* Usually not needed */

  </style>
</head>
<body>
  <!-- Login Screen -->
  <div id="login-container">
    <h2>Login to WanderingLegends</h2>
    <button onclick="googleLogin()">Sign in with Google</button>
    <button onclick="anonymousLogin()">Continue Anonymously</button>
    <p id="login-message"></p>
  </div>

  <!-- Character Selection Screen -->
  <div id="character-selection" class="screen hidden">
    <h2>Select Your Character</h2>
    <div id="existing-characters">
      <p>Choose your character:</p>
      <div id="character-list" class="class-options"></div>
    </div>
    <button id="confirm-character-selection">Confirm Selection</button>
    <button id="create-new-character">Create New Character</button>
  </div>

  <!-- Character Creation Screen -->
  <div id="character-creation" class="screen hidden">
    <h2>Create Your Character</h2>
    <div class="class-options">
      <!-- Class options -->
      <div class="class-option" data-class="Warrior"><img src="/images/classes/warrior.png" alt="Warrior"><h3>Warrior</h3><p>...</p></div>
      <div class="class-option" data-class="Wizard"><img src="/images/classes/wizard.png" alt="Wizard"><h3>Wizard</h3><p>...</p></div>
      <div class="class-option" data-class="Rogue"><img src="/images/classes/rogue.png" alt="Rogue"><h3>Rogue</h3><p>...</p></div>
      <div class="class-option" data-class="Cleric"><img src="/images/classes/cleric.png" alt="Cleric"><h3>Cleric</h3><p>...</p></div>
    </div>
    <label for="characterName">Character Name:</label>
    <input type="text" id="characterName" name="characterName" maxlength="20" pattern="^[a-zA-Z0-9\s\-']{3,20}$" required>
    <button id="confirm-character">Confirm</button>
  </div>

  <!-- Game UI -->
  <div id="map-container"> <!-- Initially hidden -->
    <button onclick="logout()" style="position: absolute; top: 10px; left: 10px; z-index: 1001;">Logout</button>
    <div id="map"></div>
    <!-- Removed queueStatus div -->
  </div>

  <!-- Debug Panel -->
  <div id="debugPanel"></div> <!-- Controlled by JS -->

  <!-- Overlays -->
  <div id="character-card-overlay" class="overlay hidden">
    <div class="character-card video-game-theme"> <!-- Content as defined before -->
        <div class="card-top-row">
            <div class="portrait-section"><img id="character-card-image" src="/images/classes/rogue.png" alt="Character Portrait"/></div>
            <div class="basic-info">
                <h2 id="character-card-name">Name</h2><p id="character-card-class">Class</p>
                <div class="level-xp-row"><span class="level-label">Lvl: </span><span id="character-card-level">1</span></div>
                <div class="level-xp-row"><span class="xp-label">XP: </span><span id="character-card-xp">0</span> / <span id="character-card-xpRequired">100</span></div>
            </div>
        </div>
        <div class="hp-ac-row">
            <div class="icon-stat"><svg class="stat-icon" viewBox="0 0 512 512" fill="#e60000"><path d="M462.3 62.7c-54.5-46.4-136-38.3-186.4 13.2L256 96.4l-19.9-20.5c-50.3-51.4-131.8-59.5-186.4-13.2 -62.8 53.6-66.1 149.8-9.9 207.7l193.5 199.8c6.2 6.4 14.4 9.6 22.7 9.6s16.5-3.2 22.7-9.6l193.5 -199.8C528.4 212.5 525.1 116.3 462.3 62.7z"/></svg><span id="character-card-hp">0</span></div>
            <div class="icon-stat"><svg class="stat-icon" viewBox="0 0 512 512" fill="#ffd700"><path d="M466.5 83.7L278.6 4.2c-8.5-3.5-18-3.5-26.5 0L45.5 83.7c-11.7 4.8-19.5 16.2-19.5 28.7 0 221.7 134.7 337.9 223.4 394.1 9.8 6.2 22.2 6.2 32 0C401.3 450.3 536 334.1 536 112.4c0-12.5-7.8-23.9-19.5-28.7zM256 456.2c-76.2-50.8-176-148.2-176-315.1l176 -68 176 68c0 166.9-99.8 264.3-176 315.1z"/></svg><span id="character-card-ac">0</span></div>
        </div>
        <div class="stat-section"><h3>ATTACKS PER ROUND</h3><div class="stat-subrow"><span>Main Hand: <strong id="character-card-mainAttacks">0</strong></span><span>Off Hand: <strong id="character-card-offAttacks">0</strong></span></div></div>
        <div class="stat-section"><h3>DAMAGE REDUCTION</h3><div class="stat-subrow"><span>Physical: <strong id="character-card-physdr">0</strong></span><span>Magical: <strong id="character-card-magdr">0</strong></span></div></div>
        <div class="stat-section"><h3>SAVE</h3><div class="stat-subrow"><strong id="character-card-save">0</strong></div></div>
        <div class="card-actions"><button id="open-inventory-button">Open Inventory</button></div>
    </div>
  </div>

  <div id="creature-card" class="overlay hidden"> <!-- Make it an overlay -->
    <div class="creature-card"> <!-- Inner card for styling -->
        <div class="card-top-corners"><div id="card-cr" class="card-cr">0</div><div id="card-exp" class="card-exp">0</div></div>
        <div class="card-top"><h2 id="card-name">Creature</h2></div>
        <div class="card-image-container"><img id="card-image" src="" alt="Creature Image" /></div>
        <div class="card-bottom"><button id="attack-button">Attack!</button><button id="run-button">Run!</button></div>
    </div>
  </div>

   <div id="item-card" class="overlay hidden">
     <div class="item-card"> <!-- Inner card for styling -->
        <div class="item-card-header"><h2 id="item-card-name">Item Name</h2></div>
        <div class="item-card-body">
            <img id="item-card-image" src="" alt="Item Image" />
            <div class="item-card-stats">
                <div class="item-card-row"><span class="gold-icon">💰</span><span id="item-card-goldValue">0 gold</span></div>
                <div class="item-card-row" id="item-card-hit"></div><div class="item-card-row" id="item-card-damage"></div>
            </div>
            <div id="item-card-specialAbilities" class="item-card-specialAbilities"></div>
            <p id="item-card-description" class="item-card-description"></p>
        </div>
        <div class="item-card-actions"><button id="close-item-card">Close</button></div>
     </div>
   </div>

  <div id="inventory-card" class="overlay hidden">
    <div class="inventory-card"> <!-- Inner card -->
      <div class="inventory-header"><h2>Inventory</h2><button id="close-inventory-card">Close</button></div>
      <div class="inventory-section equipment-section">
        <h3>Equipment</h3>
        <div class="equipment-grid">
          <div class="equipment-slot"><div class="slot-header">Main Hand</div><div class="slot" id="slot-main-hand" data-slot="mainHand" data-type="equipment" draggable="true">Empty</div></div>
          <div class="equipment-slot"><div class="slot-header">Off Hand</div><div class="slot" id="slot-off-hand" data-slot="offHand" data-type="equipment" draggable="true">Empty</div></div>
          <div class="equipment-slot"><div class="slot-header">Armor</div><div class="slot" id="slot-armor" data-slot="armor" data-type="equipment" draggable="true">Empty</div></div>
          <div class="equipment-slot"><div class="slot-header">Accessory</div><div class="slot" id="slot-accessory" data-slot="accessory" data-type="equipment" draggable="true">Empty</div></div>
        </div>
      </div>
      <div class="inventory-section bag-section">
        <h3>Bag</h3>
        <div class="bag-grid">
          <!-- Define 25 bag slots -->
          <div class="bag-slot" id="bag-slot1" data-slot="slot1" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot2" data-slot="slot2" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot3" data-slot="slot3" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot4" data-slot="slot4" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot5" data-slot="slot5" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot6" data-slot="slot6" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot7" data-slot="slot7" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot8" data-slot="slot8" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot9" data-slot="slot9" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot10" data-slot="slot10" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot11" data-slot="slot11" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot12" data-slot="slot12" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot13" data-slot="slot13" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot14" data-slot="slot14" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot15" data-slot="slot15" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot16" data-slot="slot16" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot17" data-slot="slot17" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot18" data-slot="slot18" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot19" data-slot="slot19" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot20" data-slot="slot20" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot21" data-slot="slot21" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot22" data-slot="slot22" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot23" data-slot="slot23" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot24" data-slot="slot24" data-type="bag" draggable="true">Empty</div>
          <div class="bag-slot" id="bag-slot25" data-slot="slot25" data-type="bag" draggable="true">Empty</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Battle Card Overlay -->
  <div id="battle-card" class="battle-card modern-battle hidden"> <!-- ENSURE 'hidden' IS HERE -->
      <!-- ENEMY AREA -->
      <div class="combat-section enemy-section">
          <div class="combatant-info">
              <div class="details">
                  <h4 class="enemy-name">Enemy Name</h4>
                  <div class="stats-row">
                      <span>AC: <span class="enemy-ac">0</span></span>
                      <span>Save: <span class="enemy-save">0</span></span>
                  </div>
                  <div class="stats-row dr-row">
                      <span>P.DR: <span class="enemy-phys-dr">0</span></span>
                      <span>M.DR: <span class="enemy-mag-dr">0</span></span>
                  </div>
              </div>
              <img class="combatant-portrait enemy-image" src="/images/enemy-placeholder.png" alt="Enemy">
          </div>
          <div class="hp-bar-container">
              <div class="hp-bar enemy-hp-bar"><div class="hp-fill"></div><span class="hp-text"><span class="enemy-current-hp">0</span>/<span class="enemy-max-hp">0</span></span></div>
          </div>
          <div class="status-effects enemy-status"></div>
      </div>
      <!-- COMBAT LOG AREA -->
      <div class="combat-log-area"><ul id="combat-log-list"><li>Battle Started!</li></ul></div>
      <!-- PLAYER AREA -->
      <div class="combat-section player-section">
          <div class="status-effects player-status"></div>
          <div class="hp-bar-container">
              <div class="hp-bar player-hp-bar"><div class="hp-fill"></div><span class="hp-text"><span id="player-current-hp">0</span>/<span id="player-max-hp">0</span></span></div>
          </div>
          <div class="combatant-info">
              <img id="player-image" class="combatant-portrait" src="/images/character-placeholder.png" alt="Player">
              <div class="details">
                  <h4 id="player-name">Player Name</h4>
                  <p>Lvl <span id="player-level">1</span> <span id="player-class">Class</span></p>
                  <div class="stats-row">
                      <span>AC: <span id="player-ac">0</span></span>
                      <span>Save: <span id="player-save">0</span></span>
                  </div>
                  <div class="stats-row dr-row">
                      <span>P.DR: <span id="player-phys-dr">0</span></span>
                      <span>M.DR: <span id="player-mag-dr">0</span></span>
                  </div>
                  <!-- Attack details were removed from immediate view, kept in JS data -->
              </div>
          </div>
      </div>
      <!-- ACTION BAR -->
      <div class="action-bar">
          <button id="action-attack-mh" class="action-button attack-btn">Attack (MH)</button>
          <button id="action-attack-oh" class="action-button attack-btn" disabled>Attack (OH)</button>
          <button id="action-special" class="action-button special-btn" disabled>Special</button>
          <button id="action-item" class="action-button item-btn" disabled>Item</button>
          <button id="end-turn" class="action-button end-btn">End Turn</button>
      </div>
      <!-- Turn Order Overlay -->
      <div id="turn-order-bar" class="turn-order-overlay"></div>
  </div>

  <!-- Bottom Menu -->
  <div id="bottom-menu"> <!-- Initially hidden, shown by JS -->
    <button id="inventory-button">Inventory</button>
    <div id="portrait-container">
      <img id="character-portrait" src="/images/character-placeholder.png" alt="Character Portrait">
    </div>
    <button id="settings-button">Settings</button>
  </div>


  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <!-- Photon SDK -->
  <script src="photon.js"></script>
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    // --- Global Variables ---
    let gameShown = false;
    let spawnConfig = {};
    let lastSpawnCenter = null;
    let lastPlayerPosition = null;
    const REGEN_THRESHOLD = 300; // meters
    let spawnMarkers = {};
    let selectedClass = null;
    let selectedCharacter = null;
    let globalLevelTable = {};
    let creatureTable = {};
    let currentSpawnForBattle = null;
    let currentBattleData = null; // Holds the authoritative state for the current battle UI
    let photonClient;
    let map; // Make map accessible globally within script
    let playerMarker; // Player marker on map
    let playerActionZone; // Action zone circle

    // --- Firebase Init ---
    const firebaseConfig = {
        apiKey: "AIzaSyBkZV0Y0wQ2WtWywyzCo0w0rzh8RhJ2bAU", // Replace with your actual config if different
        authDomain: "wanderinglegends-12cc2.web.app",
        projectId: "wanderinglegends-12cc2",
        storageBucket: "wanderinglegends-12cc2.appspot.com",
        messagingSenderId: "315537974549",
        appId: "1:315537974549:web:d9d75f64b453debce7b51c",
        measurementId: "G-4BY9D34ZW9"
    };
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const auth = firebase.auth(); // Use auth shortcut

    // --- Debugging & UI Helpers ---
    function debugLog(message, isError = false) {
      const debugDiv = document.getElementById("debugPanel");
      if (!debugDiv) return; // Exit if panel not found
       if (debugDiv.style.display === 'none') debugDiv.style.display = 'block'; // Show if hidden
      const p = document.createElement("p");
      p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; // Add timestamp
      if (isError) p.style.color = "red";
      debugDiv.appendChild(p);
      debugDiv.scrollTop = debugDiv.scrollHeight; // Auto-scroll
      if (isError) { console.error("DEBUG:", message); }
      else { console.log("DEBUG:", message); }
    }

    function showMessage(message, isError = false) {
      const messageBox = document.getElementById("login-message");
      if (!messageBox) return;
      messageBox.textContent = message;
      messageBox.style.color = isError ? "red" : "green";
      debugLog("Login Message: " + message, isError);
    }

    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden')); // Hide all first
      const screenToShow = document.getElementById(screenId);
      if (screenToShow) {
          screenToShow.classList.remove('hidden');
          screenToShow.classList.add('visible'); // Use visible for clarity if needed by CSS
          debugLog(`Showing screen: ${screenId}`);
      } else {
          debugLog(`Error: Screen with ID ${screenId} not found.`, true);
      }
    }

     // --- Combat Log Helper ---
     function addCombatLogMessage(message) {
        const logList = document.getElementById("combat-log-list");
        if (logList) {
            const newItem = document.createElement("li");
            newItem.textContent = message;
            logList.appendChild(newItem);
            logList.scrollTop = logList.scrollHeight; // Auto-scroll
        } else {
            console.warn("Combat log list element not found.");
        }
    }

    // --- Data Loading ---
    function loadCreatureTable() { /* ... remains the same ... */
        return database.ref("creatures").once("value").then(snapshot => {
            creatureTable = snapshot.val() || {};
            debugLog(`Creature table loaded (${Object.keys(creatureTable).length} entries).`);
        }).catch(err => debugLog("Error loading creature table: " + err.message, true));
    }
    async function loadSpawnData() { /* ... remains the same ... */
        try {
            let response = await fetch("spawnData.json");
            let data = await response.json();
            spawnConfig = {}; // Reset before loading
            data.spawnTypes.forEach(spawn => { spawnConfig[spawn.type] = spawn; });
            debugLog("Loaded spawn configuration.");
        } catch (error) { debugLog("Error loading spawn data: " + error.message, true); }
    }
    function loadGlobalLevelTable() { /* ... remains the same ... */
        database.ref('levelTable').once('value').then(snapshot => {
            if (snapshot.exists()) { globalLevelTable = snapshot.val(); debugLog("Global level table loaded."); }
             else { debugLog("No global level table found in Firebase."); }
        }).catch(error => { console.error("Error loading global level table:", error); });
    }


    // --- Authentication ---
    function googleLogin() { /* ... remains the same ... */
        const provider = new auth.GoogleAuthProvider();
        debugLog("Initiating Google sign-in redirect...");
        auth.signInWithRedirect(provider).catch(error => {
            debugLog("Google sign-in error: " + error.message, true);
            showMessage("Sign-in failed: " + error.message, true);
        });
    }
    function anonymousLogin() { /* ... remains the same ... */
        debugLog("Attempting anonymous sign-in...");
        auth.signInAnonymously().catch(error => {
            debugLog("Anonymous sign-in error: " + error.message, true);
            showMessage("Anonymous sign-in failed: " + error.message, true);
        });
    }
    auth.getRedirectResult().then(result => { /* ... remains the same ... */
        if (result.user) { debugLog("getRedirectResult: User signed in."); }
         else { debugLog("getRedirectResult: No user found."); }
    }).catch(error => {
        debugLog("getRedirectResult error: " + error.message, true);
        showMessage("Sign-in failed: " + error.message, true);
    });

    auth.onAuthStateChanged(user => {
      debugLog(`onAuthStateChanged: User is ${user ? 'present' : 'null'}. Game shown: ${gameShown}`);
      if (user && !gameShown) {
        gameShown = true; // Set flag immediately
        debugLog("User detected: " + (user.uid));
        document.getElementById("login-container").style.display = "none"; // Hide login
        postLoginFlow(user.uid); // Pass UID
      } else if (!user) {
        // Handle user signed out state if needed (e.g., show login screen)
        debugLog("No user signed in.");
        gameShown = false; // Reset flag if user signs out
        // Ensure non-game screens are hidden and login is shown
        document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('map-container').style.display = 'none';
        document.getElementById('bottom-menu').style.display = 'none';
        document.getElementById("login-container").style.display = "flex";
      }
    });

    function logout() {
      debugLog("Logging out...");
      auth.signOut().then(() => {
          debugLog("Sign-out successful. Reloading page.");
          location.reload(); // Reload to reset state cleanly
      }).catch(error => {
           debugLog("Sign-out error: " + error.message, true);
      });
    }

    // --- Post Login / Character Flow ---
    function postLoginFlow(uid) {
        if (!uid) {
            debugLog("postLoginFlow called without UID!", true);
            return;
        }
      database.ref(`players/${uid}`).once('value').then(snapshot => {
        if (snapshot.exists() && snapshot.val().activeCharacter) {
             // User has characters and likely an active one set
             const activeCharId = snapshot.val().activeCharacter;
             const charData = snapshot.val()[activeCharId];
             if (charData) {
                debugLog(`Active character ${activeCharId} (${charData.name}) found. Initializing game.`);
                selectedCharacter = activeCharId; // Set the global selected character
                document.getElementById("character-selection").classList.add('hidden');
                document.getElementById("character-creation").classList.add('hidden');
                document.getElementById("map-container").style.display = "flex"; // Show map container
                initializeGame(); // Start the game
             } else {
                 debugLog("Active character ID found but data missing. Showing selection.");
                 showScreen('character-selection');
                 loadUserCharacters(uid);
             }
        } else if (snapshot.exists()) {
          // User has character data but no activeCharacter set, or structure is unexpected
           debugLog("Character data exists but no active character set. Showing selection.");
           showScreen('character-selection');
           loadUserCharacters(uid);
        }
         else {
           debugLog("No character data found. Showing creation screen.");
           showScreen('character-creation');
        }
      }).catch(error => {
          debugLog("Error checking player data: " + error.message, true);
          // Maybe show an error message screen or default to creation
          showScreen('character-creation');
      });
    }

    function loadUserCharacters(uid) { /* ... remains the same ... */
        const container = document.getElementById("character-list");
        container.innerHTML = ""; // Clear list

        database.ref(`players/${uid}`).once('value').then(snapshot => {
            if (!snapshot.exists() || Object.keys(snapshot.val()).length <= 1) { // Check if only 'activeCharacter' exists
                document.getElementById("existing-characters").innerHTML = "<p>No characters found. Create a new one.</p>";
                return;
            }
            document.getElementById("existing-characters").innerHTML = "<p>Choose your character:</p>"; // Reset header

            snapshot.forEach(childSnapshot => {
                const character = childSnapshot.val();
                const key = childSnapshot.key;
                if (key === "activeCharacter") return; // Skip the activeCharacter key itself

                if (!character || !character.class || !character.name) {
                    console.error("Malformed character data:", key, character); return;
                }

                const charDiv = document.createElement("div");
                charDiv.classList.add("class-option");
                charDiv.dataset.charId = key;
                charDiv.innerHTML = `<img src="/images/classes/${character.class.toLowerCase()}.png" alt="${character.name}"><h3>${character.name}</h3>`;
                container.appendChild(charDiv);

                charDiv.addEventListener("click", function () {
                    document.querySelectorAll('#character-list .class-option').forEach(opt => opt.classList.remove('selected'));
                    charDiv.classList.add("selected");
                    selectedCharacter = key;
                    debugLog("Selected Character ID: " + selectedCharacter);
                });
            });
        }).catch(error => { console.error("Error loading characters:", error); });
    }

    // --- Character Listeners ---
    document.getElementById('create-new-character')?.addEventListener('click', () => showScreen('character-creation'));
    document.querySelectorAll('#character-creation .class-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('#character-creation .class-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            selectedClass = option.getAttribute('data-class');
             debugLog(`Selected class for creation: ${selectedClass}`);
        });
    });
    document.getElementById('confirm-character')?.addEventListener('click', function() { /* ... create character logic remains the same ... */
        const characterName = document.getElementById('characterName').value.trim();
        if (!characterName || !/^[a-zA-Z0-9\s\-']{3,20}$/.test(characterName)) { alert("Please enter a valid character name (3-20 letters, numbers, spaces, -, ')."); return; }
        if (!selectedClass) { alert("Please select a class."); return; }

        database.ref('classDefaults/' + selectedClass).once('value').then(snapshot => {
            if (!snapshot.exists()) { alert("Error: Class defaults not found."); return; }
            const classData = snapshot.val();
            const defaultInventory = { equipment: { mainHand: null, offHand: null, armor: null, accessory: null }, bag: {} }; // Simplified default

            const newPlayer = {
                class: selectedClass, name: characterName,
                stats: { ...classData.stats, level: 1, xp: 0 },
                inventory: defaultInventory,
                // abilities: { ... } // Add later if needed
            };

            const uid = auth.currentUser.uid;
            const newCharRef = database.ref('players/' + uid).push(newPlayer); // Get ref to new char
            newCharRef.then(() => {
                const newCharId = newCharRef.key;
                 debugLog(`Character created successfully with ID: ${newCharId}`);
                 // Set this new character as active and proceed to game
                 database.ref(`players/${uid}/activeCharacter`).set(newCharId).then(() => {
                     selectedCharacter = newCharId; // Update global state
                     document.getElementById("character-creation").classList.add('hidden');
                     document.getElementById("map-container").style.display = "flex";
                     initializeGame();
                 }).catch(err => debugLog("Error setting active character: " + err.message, true));
            }).catch(error => debugLog("Error creating character: " + error.message, true));
        }).catch(error => debugLog("Error retrieving class defaults: " + error.message, true));
    });

    document.getElementById('confirm-character-selection')?.addEventListener('click', function () {
        if (!selectedCharacter) { alert("Please select a character."); return; }
        const uid = auth.currentUser.uid;
        database.ref(`players/${uid}/activeCharacter`).set(selectedCharacter).then(() => {
            debugLog("Active character confirmed: " + selectedCharacter);
            document.getElementById("character-selection").classList.add('hidden');
            document.getElementById("map-container").style.display = "flex";
            initializeGame();
        }).catch(error => { console.error("Error selecting character:", error); });
    });

    // --- Photon Setup & Utilities ---
    // tryJoinThenCreateRoom, prepareAndJoinBattleRoom etc. remain the same as provided previously
    // ... (Include the definitions for tryJoinThenCreateRoom, prepareAndJoinBattleRoom, robustLeaveRoom, waitForPhotonState here) ...
    /**
 * Attempts to join a room. If the join doesn't succeed quickly
 * (likely indicating it doesn't exist), it then attempts to create it.
 * Uses temporary global handlers.
 *
 * @param {string} roomName - The name of the room.
 * @param {object} options - Room options for creation.
 * @param {number} joinAttemptTimeout - Max time (ms) to wait for join before assuming failure and trying create.
 * @param {number} createAttemptTimeout - Max time (ms) to wait for create after join fails.
 * @returns {Promise<Photon.LoadBalancing.Room>} Resolves with the Room object, rejects on error/timeout.
 */
    function tryJoinThenCreateRoom(roomName, options, joinAttemptTimeout = 1500, createAttemptTimeout = 10000) {
        return new Promise((resolve, reject) => {
            debugLog(`[tryJoinThenCreateRoom] Attempting sequence for room: ${roomName}`);

            const originalOnJoin = photonClient.onJoinRoom;
            const originalOnError = photonClient.onError;
            let handlersRestored = false;
            let overallTimeoutHandle = null;
            let joinSpecificTimeoutHandle = null;
            let currentPhase = 'joining'; // 'joining' or 'creating'

            const cleanup = (error = null, room = null) => {
                if (handlersRestored) return;
                handlersRestored = true;

                clearTimeout(overallTimeoutHandle);
                clearTimeout(joinSpecificTimeoutHandle);
                photonClient.onJoinRoom = originalOnJoin;
                photonClient.onError = originalOnError;
                debugLog(`[tryJoinThenCreateRoom] Cleaned up handlers for ${roomName}.`);

                if (error) reject(error);
                else if (room) resolve(room);
                else reject(new Error(`[tryJoinThenCreateRoom] Cleanup called unexpectedly for ${roomName}`));
            };

            // Overall timeout for the entire sequence
            overallTimeoutHandle = setTimeout(() => {
                debugLog(`[tryJoinThenCreateRoom] Overall sequence timed out for ${roomName} (Phase: ${currentPhase})`, true);
                cleanup(new Error(`Overall timeout waiting to join/create room: ${roomName}`));
            }, joinAttemptTimeout + createAttemptTimeout + 500); // Total time + buffer

            // --- Temporary Handlers ---
            photonClient.onJoinRoom = (room) => { // Parameter 'room' might be unreliable initially
                const currentRoom = photonClient.myRoom(); // Get the room object directly from the client
                debugLog(`[tryJoinThenCreateRoom] Global onJoinRoom triggered (Phase: ${currentPhase}). Parameter room name: ${room?.name}, Client myRoom name: ${currentRoom?.name}`);
                if (currentRoom && currentRoom.name === roomName) {
                    debugLog(`[tryJoinThenCreateRoom] Confirmed in target room via myRoom(): ${currentRoom.name}`);
                    cleanup(null, currentRoom); // SUCCESS!
                } else if (room && room.name === roomName) {
                    debugLog(`[tryJoinThenCreateRoom] Confirmed in target room via event parameter: ${room.name}`);
                    cleanup(null, room); // SUCCESS! (Fallback)
                } else {
                    debugLog(`[tryJoinThenCreateRoom] Joined room "${currentRoom?.name}" (myRoom) / "${room?.name}" (param) but expected "${roomName}". Ignoring.`);
                }
            };

            photonClient.onError = (errorCode, errorMsg) => {
                debugLog(`[tryJoinThenCreateRoom] Global onError triggered (Phase: ${currentPhase}). Code: ${errorCode}, Msg: ${errorMsg}`, true);
                cleanup(new Error(`Photon error during ${currentPhase} room ${roomName}: ${errorMsg} (${errorCode})`));
            };
            debugLog(`[tryJoinThenCreateRoom] Temporary global handlers set for ${roomName}.`);

            // --- Phase 1: Try to Join ---
            currentPhase = 'joining';
            debugLog(`[tryJoinThenCreateRoom] Phase 1: Calling joinRoom: ${roomName}`);
            const joinResult = photonClient.joinRoom(roomName);
            debugLog(`[tryJoinThenCreateRoom] joinRoom call returned: ${joinResult}`);
            if (!joinResult) {
                debugLog(`[tryJoinThenCreateRoom] joinRoom call failed immediately. Aborting. Client state: ${photonClient.state}`, true);
                cleanup(new Error(`joinRoom call failed immediately for ${roomName}. Client state: ${photonClient.state}`)); return;
            }

            // Timeout for JOIN attempt
            joinSpecificTimeoutHandle = setTimeout(() => {
                debugLog(`[tryJoinThenCreateRoom] Join attempt timed out after ${joinAttemptTimeout}ms. Assuming room doesn't exist. Proceeding to create.`);
                currentPhase = 'creating';
                debugLog(`[tryJoinThenCreateRoom] Phase 2: Calling createRoom: ${roomName} with options: ${JSON.stringify(options)}`);
                const createResult = photonClient.createRoom(roomName, options);
                debugLog(`[tryJoinThenCreateRoom] createRoom call returned: ${createResult}`);
                if (!createResult) {
                    debugLog(`[tryJoinThenCreateRoom] createRoom call failed immediately. Aborting. Client state: ${photonClient.state}`, true);
                    cleanup(new Error(`createRoom call failed immediately for ${roomName}. Client state: ${photonClient.state}`));
                }
            }, joinAttemptTimeout);
            debugLog(`[tryJoinThenCreateRoom] Waiting up to ${joinAttemptTimeout}ms for join success before attempting create...`);
        });
    }
    async function prepareAndJoinBattleRoom(roomName, options, timeout = 20000) {
        debugLog(`[prepareAndJoinBattleRoom] Starting preparation for room: ${roomName}`);
        const overallStartTime = Date.now();
        const checkTimeout = (operationTimeout) => {
            const elapsed = Date.now() - overallStartTime;
            if (elapsed > timeout) throw new Error(`Overall timeout (${timeout}ms) exceeded for ${roomName}`);
            if (operationTimeout && elapsed > operationTimeout) throw new Error(`Operation specific timeout exceeded for ${roomName}`);
        };
        try {
            const lobbyWaitTimeout = overallStartTime + 8000;
            debugLog("[prepareAndJoinBattleRoom] Ensuring client is connected and in lobby...");
            checkTimeout(lobbyWaitTimeout);
            await waitForPhotonState(Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby, 8000, 'InitialLobbyCheck');
            debugLog("[prepareAndJoinBattleRoom] Client confirmed in lobby.");
            if (photonClient.isJoinedToRoom()) {
                const currentRoom = photonClient.myRoom();
                debugLog(`[prepareAndJoinBattleRoom] Client is currently in room: ${currentRoom?.name}`);
                if (currentRoom?.name === roomName) {
                    debugLog(`[prepareAndJoinBattleRoom] Already in the target room: ${roomName}. Success!`); return currentRoom;
                } else {
                    const leaveTimeout = overallStartTime + 15000;
                    debugLog(`[prepareAndJoinBattleRoom] In a different room. Attempting graceful leave...`); checkTimeout(leaveTimeout);
                    try {
                        await robustLeaveRoom(7000); debugLog("[prepareAndJoinBattleRoom] Successfully left previous room.");
                        const postLeaveLobbyTimeout = overallStartTime + 18000;
                        debugLog("[prepareAndJoinBattleRoom] Waiting for lobby state after leaving room..."); checkTimeout(postLeaveLobbyTimeout);
                        await waitForPhotonState(Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby, 3000, 'PostLeaveLobbyCheck');
                        debugLog("[prepareAndJoinBattleRoom] Re-entered lobby after leaving.");
                    } catch (leaveError) {
                        debugLog(`[prepareAndJoinBattleRoom] Graceful leave failed: ${leaveError.message}. Aborting operation.`, true);
                        throw new Error(`Failed to leave previous room '${currentRoom?.name}': ${leaveError.message}`);
                    }
                }
            } else {
                debugLog("[prepareAndJoinBattleRoom] Client is not currently in a room.");
                await waitForPhotonState(Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby, 1000, 'NotInRoomLobbyCheck');
            }
            const joinCreateOuterTimeout = overallStartTime + timeout;
            debugLog(`[prepareAndJoinBattleRoom] Proceeding to join/create target room: ${roomName}`); checkTimeout(joinCreateOuterTimeout);
            const joinAttemptDuration = 1500; debugLog(`[prepareAndJoinBattleRoom] Defined joinAttemptDuration: ${joinAttemptDuration}`);
            const timeElapsedSoFar = Date.now() - overallStartTime;
            const createAttemptDuration = timeout - timeElapsedSoFar - joinAttemptDuration - 500; debugLog(`[prepareAndJoinBattleRoom] Calculated createAttemptDuration: ${createAttemptDuration}`);
            if (createAttemptDuration <= 1000) { throw new Error(`Not enough time remaining for create operation. Needed >1000ms, have ${createAttemptDuration}ms.`); }
            const joinedRoom = await tryJoinThenCreateRoom(roomName, options, joinAttemptDuration, createAttemptDuration);
            debugLog(`[prepareAndJoinBattleRoom] Successfully joined/created room: ${joinedRoom.name}`); return joinedRoom;
        } catch (error) {
            debugLog(`[prepareAndJoinBattleRoom] Error during operation for room ${roomName}: ${error.message}`, true);
            try { const finalState = photonClient.state; const finalStateValue = typeof finalState === 'function' ? finalState() : finalState; debugLog(`[prepareAndJoinBattleRoom] State at time of error: ${finalStateValue}`); } catch (e) {}
            throw error;
        }
    }

    // --- Spawn Management ---
    // clearSpawnPoints, checkSpawnManager, electSpawnManager, moveSpawnsIfManager, startMovingSpawns remain the same
    // ... (Include those function definitions here) ...
    async function checkSpawnManager() { /* ... code ... */
        const snapshot = await database.ref("spawnManager").once("value");
        if (snapshot.exists() && snapshot.val().uid) { debugLog("Spawn manager exists: " + snapshot.val().uid); return false; } return true;
    }
    async function electSpawnManager() { /* ... code ... */
        const canBecomeLeader = await checkSpawnManager(); if (!canBecomeLeader) return; const currentUser = auth.currentUser; if (!currentUser) return; await database.ref("spawnManager").set({ uid: currentUser.uid }); debugLog(`Elected new spawn manager: ${currentUser.uid}`); startMovingSpawns();
    }
    async function moveSpawnsIfManager() { /* ... code ... */
        const managerSnapshot = await database.ref("spawnManager").once("value"); if (!managerSnapshot.exists() || managerSnapshot.val().uid !== auth.currentUser?.uid) { /*debugLog("Not the spawn manager. Skipping movement.");*/ return; } debugLog("Spawn manager moving spawns..."); const now = Date.now(); const spawnsSnapshot = await database.ref("spawnPoints").once("value"); let updates = {}; spawnsSnapshot.forEach(snapshot => { let spawn = snapshot.val(); if (!spawn || !spawn.lastMovedAt || !spawn.respawnTime || now - spawn.lastMovedAt < spawn.respawnTime) return; let offset = generateRandomOffset(10, spawn.location.lat); let newLat = spawn.location.lat + offset.latOffset; let newLng = spawn.location.lng + offset.lngOffset; updates[snapshot.key + "/location"] = { lat: newLat, lng: newLng }; updates[snapshot.key + "/lastMovedAt"] = now; }); if (Object.keys(updates).length > 0) { await database.ref("spawnPoints").update(updates); debugLog(`Moved spawns: ${Object.keys(updates).length} spawns updated.`); }
    }
    function startMovingSpawns() { /* ... code ... */
        moveSpawnsIfManager(); setInterval(moveSpawnsIfManager, 600000); // Move every 10 minutes
    }
    database.ref("spawnManager").on("value", async snapshot => { /* ... code ... */
        if (!snapshot.exists() || !snapshot.val().uid) { debugLog("No spawn manager detected. Electing a new one..."); electSpawnManager(); }
    });
    database.ref("spawnPoints").on("child_changed", snapshot => { /* ... update marker logic ... */
        const spawn = snapshot.val(); if (!spawn || !spawn.location) return; debugLog(`Spawn ${snapshot.key} moved to [${spawn.location.lat}, ${spawn.location.lng}]`); let marker = spawnMarkers[snapshot.key]; if (marker) { marker.setLatLng([spawn.location.lat, spawn.location.lng]); }
    });
    async function clearSpawnPoints() { /* ... code ... */ try { await database.ref("spawnPoints").remove(); debugLog("Cleared all spawn points."); } catch (error) { debugLog("Error clearing spawn points: " + error.message, true); } }
    function getSpawnColor(type) { /* ... remains the same ... */ const colors={"creature":"green","dungeon":"darkred","inn":"orange","shop":"purple","quest":"blue","keep":"brown","lair":"black","publicEvent":"red","worldBoss":"gold"}; return colors[type]||"gray"; }


    // --- Game Initialization ---
    async function initializeGame() {
      debugLog("Initializing game logic...");
      // Explicitly hide overlays on init
      document.getElementById('battle-card')?.classList.add('hidden');
      document.getElementById('character-card-overlay')?.classList.add('hidden');
      document.getElementById('inventory-card')?.classList.add('hidden');
      document.getElementById('item-card')?.classList.add('hidden');
      document.getElementById('creature-card')?.classList.add('hidden'); // Hide creature card too initially
      debugLog("Ensured all overlay cards are hidden initially.");

      if (!map) { // Initialize map only once
          map = L.map("map").setView([37.7749, -122.4194], 13); // Default view
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19, attribution: "&copy; OpenStreetMap contributors"
          }).addTo(map);
          debugLog("Leaflet map loaded.");

          // Setup Player Marker & Action Zone only once
          playerMarker = L.marker([0, 0], { icon: L.divIcon({ className: '', html: '<div class="blinking-dot"></div>', iconSize: [15,15], iconAnchor: [7,7] }) }).addTo(map);
          playerActionZone = L.circle([0, 0], { color: "blue", fillColor: "rgba(0, 0, 255, 0.3)", fillOpacity: 0.3, radius: 300 }).addTo(map);
          map.on("movestart", function() { /* autoCenter = false; */ }); // Auto-centering logic removed for now
      }

      // Load necessary data
      await loadSpawnData();
      await loadCreatureTable();
      await electSpawnManager(); // Handles spawn movement if elected
      await loadGlobalLevelTable();

      // Show bottom menu
      document.getElementById('bottom-menu').classList.add('visible'); // Use class for consistency

      // Update player portrait
      const uid = auth.currentUser?.uid;
      if (uid && selectedCharacter) {
         database.ref(`players/${uid}/${selectedCharacter}/class`).once('value').then(snapshot => {
             const playerClass = snapshot.val();
             if (playerClass) {
                 const portraitURL = `/images/classes/${playerClass.toLowerCase()}.png`;
                 document.getElementById('character-portrait').src = portraitURL;
             }
         }).catch(error => console.error("Error fetching active character class for portrait:", error));
      } else {
          debugLog("Cannot update portrait - UID or selectedCharacter missing.", true);
      }

      // Initialize Photon
      if (!photonClient || !photonClient.isConnectedToMaster()) {
            try {
                const photonAppId = "ada47d27-2453-4f9a-8ee6-b9d0f7127500"; // Replace if needed
                photonClient = new Photon.LoadBalancing.LoadBalancingClient(Photon.ConnectionProtocol.Wss, photonAppId, "1.0");
                photonClient.onStateChange = function (state) {
                     debugLog("Photon: State changed to " + state + ` (${Photon.LoadBalancing.LoadBalancingClient.StateToName(state)})`);
                     // Maybe disable initial attack button until connected?
                     const initialAttackBtn = document.getElementById('attack-button');
                     if(initialAttackBtn) initialAttackBtn.disabled = (state < Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby);
                };
                photonClient.onError = function (errorCode, errorMsg) { debugLog("Photon Error: " + errorCode + " / " + errorMsg, true); };
                photonClient.onActorJoin = function(actor) { /* ... onActorJoin logic ... */
                     debugLog(`[onActorJoin] Actor Nr: ${actor.actorNr} ${actor.isLocal ? '(Local)' : ''} joined room: ${photonClient.myRoom()?.name}`);
                     if (actor.isLocal) { /* ... Local join logic ... */
                         const currentRoom = photonClient.myRoom();
                         if (currentRoom) debugLog(`[onActorJoin - Local] Room Check - Name: ${currentRoom.name}, MaxPlayers: ${currentRoom.maxPlayers}, PlayerCount: ${currentRoom.playerCount}`);
                         else debugLog("[onActorJoin - Local] Error: Could not get current room!");
                     } else { /* ... Remote join logic ... */
                         debugLog(`[onActorJoin - Remote] Remote Actor joined. Current playerCount: ${photonClient.myRoom()?.playerCount}`);
                     }
                 };
                // Add other global handlers like onEvent if needed later
                debugLog("Connecting to Photon...");
                photonClient.connectToRegionMaster("us");
            } catch (error) { debugLog("Error initializing Photon: " + error.message, true); }
      } else {
           debugLog("Photon client already initialized and possibly connected.");
      }

      // Start location tracking if not already running (add a flag if needed)
      startLocationTracking(); // Simplified call

      // Setup Firebase spawn listener (ensure it runs only once or handles duplicates)
      setupSpawnListeners(); // Wrap listener setup

      // Cleanup timer (moved here for clarity)
      setInterval(clearSpawnPoints, 300000); // Clear spawns every 5 minutes

    } // --- End of initializeGame ---

    let firebaseSpawnListenerAttached = false; // Flag to prevent multiple listeners
    function setupSpawnListeners() {
        if (firebaseSpawnListenerAttached) return; // Don't attach multiple times
        firebaseSpawnListenerAttached = true;
        debugLog("Setting up Firebase spawn listeners.");

        database.ref("spawnPoints").on("child_added", snapshot => {
            const spawn = snapshot.val();
            const spawnId = snapshot.key;
            if (!spawn || !spawn.location || isNaN(spawn.location.lat) || isNaN(spawn.location.lng)) {
                debugLog(`Invalid spawn received: ${spawnId}`, true); return;
            }
            // Check if marker already exists to prevent duplicates on reconnect/reload
            if (spawnMarkers[spawnId]) {
                debugLog(`Marker for spawn ${spawnId} already exists, updating position.`);
                spawnMarkers[spawnId].setLatLng([spawn.location.lat, spawn.location.lng]);
                return;
            }

            debugLog(`New spawn added from Firebase: ${spawnId} - ${spawn.type}`);
            let marker;
            const latLng = [spawn.location.lat, spawn.location.lng];
            const markerOptions = { title: spawn.creatureName || spawn.type }; // Add title for hover

            if (spawn.type === "creature") {
                let iconUrl = spawn.imageUrl && spawn.imageUrl.trim() !== "" ? spawn.imageUrl : null; // "/images/creatures/default_creature.png"; // Fallback image?
                if (iconUrl) {
                    let icon = L.icon({ iconUrl: iconUrl, iconSize: [32, 32], iconAnchor: [16, 32], popupAnchor: [0, -32] }); // Adjust anchor
                    marker = L.marker(latLng, { icon: icon, ...markerOptions });
                } else { // Fallback circle marker
                    marker = L.circleMarker(latLng, { color: getSpawnColor(spawn.type), fillColor: getSpawnColor(spawn.type), fillOpacity: 0.8, radius: 8 });
                }
                marker.on("click", (event) => {
                    L.DomEvent.stopPropagation(event); // Prevent map click
                    debugLog(`Clicked creature: ${spawn.creatureName || spawnId}`);
                    showCreatureCard(spawn); // Show the pre-battle card
                });
            } else {
                marker = L.circleMarker(latLng, { color: getSpawnColor(spawn.type), fillColor: getSpawnColor(spawn.type), fillOpacity: 0.8, radius: 10, ...markerOptions });
                marker.bindPopup(`<b>${spawn.type}</b><br>Click to interact.`); // Simple popup
                marker.on("click", () => {
                    L.DomEvent.stopPropagation(event);
                    debugLog(`Clicked non-creature spawn: ${spawn.type} ${spawnId}`);
                    // TODO: Handle interaction for dungeons, inns etc. Later.
                    // For now, maybe just log:
                    addCombatLogMessage(`Interacted with ${spawn.type}.`); // Use combat log for messages
                    // joinBattleRoom(spawnId, photonClient); // Example if it was a different kind of battle
                });
            }
            marker.addTo(map);
            spawnMarkers[spawnId] = marker;
        });

         database.ref("spawnPoints").on("child_removed", snapshot => {
             const spawnId = snapshot.key;
             if (spawnMarkers[spawnId]) {
                 map.removeLayer(spawnMarkers[spawnId]);
                 delete spawnMarkers[spawnId];
                 debugLog(`Removed spawn marker: ${spawnId}`);
             }
         });
    } // --- End setupSpawnListeners ---


    function updatePlayerMarker(lat, lng) {
        if (playerMarker) playerMarker.setLatLng([lat, lng]);
        if (playerActionZone) playerActionZone.setLatLng([lat, lng]);
        // debugLog(`updatePlayerMarker: Updated to [${lat.toFixed(6)}, ${lng.toFixed(6)}]`); // Less verbose
    }

    function startLocationTracking() {
      if (!navigator.geolocation) { debugLog("Geolocation not supported.", true); return; }
      debugLog("Starting location tracking...");
      navigator.geolocation.watchPosition(
        position => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          updatePlayerMarker(lat, lng);
          lastPlayerPosition = { lat, lng };

          // Send position update via Photon if connected
           if (photonClient?.isInLobby() || photonClient?.isJoinedToRoom()) {
             try {
                let eventData = { lat: lat, lng: lng };
                // Consider sending less frequently or only if moved significantly
                photonClient.raiseEvent(1, eventData, { cache: Photon.LoadBalancing.Constants.EventCache.DoNotCache }); // Event Code 1 for position
             } catch (e) { debugLog("Error raising Photon position event: "+e.message, true); }
           }

          if (lastSpawnCenter) {
              let distanceMoved = calculateDistance(lastSpawnCenter, lastPlayerPosition);
              // debugLog(`Distance moved: ${distanceMoved.toFixed(2)}m`); // Less verbose
              if (distanceMoved > REGEN_THRESHOLD) {
                debugLog(`Player moved ${distanceMoved.toFixed(0)}m > ${REGEN_THRESHOLD}m; regenerating spawns...`);
                clearSpawnPoints().then(() => {
                   if(lastPlayerPosition) generateSpawns(lastPlayerPosition);
                   lastSpawnCenter = { ...lastPlayerPosition }; // Update center
                });
              }
          }
        },
        error => { debugLog("Error retrieving player location: " + error.message, true); },
        { enableHighAccuracy: true, maximumAge: 10000, timeout: 5000 }
      );

      // Get initial position
      navigator.geolocation.getCurrentPosition(
        position => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          debugLog(`Initial player position: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
          updatePlayerMarker(lat, lng);
          if(map) map.setView([lat, lng], 15); // Center map initially
          lastPlayerPosition = { lat, lng };
          lastSpawnCenter = { lat, lng };
          generateSpawns(lastPlayerPosition); // Initial spawn generation
        },
        error => {
             debugLog("Error retrieving initial position: " + error.message, true);
             // Handle case where initial position fails - maybe use default or ask user?
             // For now, might generate spawns at default map center if needed.
             if(!lastSpawnCenter && map) {
                const center = map.getCenter();
                lastSpawnCenter = { lat: center.lat, lng: center.lng };
                generateSpawns(lastSpawnCenter);
             }
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 } // Longer timeout for initial
      );
    }

    function calculateDistance(p1, p2) { /* ... remains the same ... */ const R=6371e3;const φ1=p1.lat*Math.PI/180;const φ2=p2.lat*Math.PI/180;const Δφ=(p2.lat-p1.lat)*Math.PI/180;const Δλ=(p2.lng-p1.lng)*Math.PI/180;const a=Math.sin(Δφ/2)*Math.sin(Δφ/2)+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));return R*c; }
    function generateRandomOffset(meters, centerLat) { /* ... remains the same ... */ const dLat=meters/111300;const dLng=meters/(111300*Math.cos(centerLat*Math.PI/180));let latOffset=(Math.random()*2-1)*dLat;let lngOffset=(Math.random()*2-1)*dLng;return{latOffset,lngOffset}; }
    async function generateSpawns(center) { /* ... logic remains the same ... */
        if (!spawnConfig || Object.keys(spawnConfig).length === 0) { debugLog("Spawn config not loaded.", true); return; }
        let totalSpawns = 0; debugLog(`Generating spawns around [${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}]`);
        for (let type in spawnConfig) {
            let config = spawnConfig[type]; let count = config.maxPerArea;
            for (let i = 0; i < count; i++) {
                let maxOffset = config.spawnRadius || 500; // Use config radius or default
                let offset = generateRandomOffset(maxOffset, center.lat);
                let newSpawn = { type: type, location: { lat: center.lat + offset.latOffset, lng: center.lng + offset.lngOffset }, lastSpawnTime: Date.now(), respawnTime: config.respawnTime, lastMovedAt: Date.now() };
                if (type === "creature") {
                    if (!creatureTable || Object.keys(creatureTable).length === 0) { debugLog("Creature table not loaded for spawn.", true); continue; }
                    const creatureKeys = Object.keys(creatureTable); const randomKey = creatureKeys[Math.floor(Math.random() * creatureKeys.length)]; const creature = creatureTable[randomKey];
                    if (!creature) { debugLog(`Invalid creature key chosen: ${randomKey}`, true); continue; }
                    newSpawn.creatureName = creature.name; newSpawn.creatureRarity = creature.rarity; newSpawn.imageUrl = creature.imageUrl; newSpawn.stats = creature.stats; newSpawn.creatureId = randomKey;
                }
                if (type === "worldBoss") newSpawn.roaming = true;
                try { await database.ref("spawnPoints").push(newSpawn); totalSpawns++; }
                 catch (error) { debugLog(`Error creating spawn ${type}: ${error.message}`, true); }
            }
        } debugLog(`Generated ${totalSpawns} spawn points.`);
    }


    // --- Stat Calculation ---
    // calculateEffectivePlayerStats function (latest version) remains the same
    // ... (Include the calculateEffectivePlayerStats function definition here) ...
    function calculateEffectivePlayerStats(baseStats, equipment, itemsData) { /* ... logic as provided previously ... */
        let effective = { ac: baseStats.ac || 10, maxHp: baseStats.hp || 10, physicalDR: baseStats.physicalDR || 0, magicalDR: baseStats.magicalDR || 0, save: baseStats.save || 0, level: baseStats.level || 1, name: baseStats.name || "Player", class: baseStats.class || "Adventurer", imageUrl: `/images/classes/${(baseStats.class || 'adventurer').toLowerCase()}.png`, mainHand: { numAttacks: baseStats.attacksPerRound?.mainHand || 1, toHitBonus: 0, damageString: "1d4+0", damageType: "bludgeoning" }, offHand: { numAttacks: baseStats.attacksPerRound?.offHand || 0, toHitBonus: 0, damageString: "1d4+0", damageType: "bludgeoning" } }; let accessoryBonus = { hit: 0, damage: 0 }; let mainHandItem = null; let offHandItem = null; let armorItem = null; let accessoryItem = null; let isTwoHanding = false; let isShielding = false;
        //debugLog(`[calculateStats] Base Stats: AC=${effective.ac} HP=${effective.maxHp} PhysDR=${effective.physicalDR} MagDR=${effective.magicalDR} Save=${effective.save} MHAtk=${effective.mainHand.numAttacks} OHAtk=${effective.offHand.numAttacks}`);
        if (!equipment) { debugLog("[calculateStats] No equipment data found. Using base/unarmed stats."); return effective; }
        if (equipment.mainHand?.itemId && itemsData[equipment.mainHand.itemId]) { mainHandItem = itemsData[equipment.mainHand.itemId]; /*debugLog(`[calculateStats] Found Main Hand: ${mainHandItem.name}`);*/ if (mainHandItem.category === 'weapon' && mainHandItem.isTwoHanded) { isTwoHanding = true; /*debugLog(`[calculateStats] Main hand weapon is Two-Handed.`);*/ } }
        if (!isTwoHanding && equipment.offHand?.itemId && itemsData[equipment.offHand.itemId]) { offHandItem = itemsData[equipment.offHand.itemId]; /*debugLog(`[calculateStats] Found Off Hand: ${offHandItem.name}`);*/ if (offHandItem.category === 'shield') { isShielding = true; /*debugLog(`[calculateStats] Off hand item is a Shield.`);*/ } } else if (isTwoHanding) { /*debugLog(`[calculateStats] Off hand slot ignored.`);*/ }
        if (equipment.armor?.itemId && itemsData[equipment.armor.itemId]) { armorItem = itemsData[equipment.armor.itemId]; /*debugLog(`[calculateStats] Found Armor: ${armorItem.name}`);*/ }
        if (equipment.accessory?.itemId && itemsData[equipment.accessory.itemId]) { accessoryItem = itemsData[equipment.accessory.itemId]; /*debugLog(`[calculateStats] Found Accessory: ${accessoryItem.name}`);*/ }
        if (armorItem) { effective.ac = armorItem.ac || effective.ac; if (armorItem.hp) effective.maxHp += armorItem.hp; if (armorItem.drBonus) { effective.physicalDR += armorItem.drBonus; effective.magicalDR += armorItem.drBonus; } if (armorItem.physicalDR) effective.physicalDR += armorItem.physicalDR; if (armorItem.magicalDR) effective.magicalDR += armorItem.magicalDR; if (armorItem.saveBonus) effective.save += armorItem.saveBonus; if (armorItem.save) effective.save += armorItem.save; }
        if (isShielding && offHandItem) { effective.ac += offHandItem.ac || 0; if (offHandItem.hp) effective.maxHp += offHandItem.hp; if (offHandItem.drBonus) { effective.physicalDR += offHandItem.drBonus; effective.magicalDR += offHandItem.drBonus; } if (offHandItem.physicalDR) effective.physicalDR += offHandItem.physicalDR; if (offHandItem.magicalDR) effective.magicalDR += offHandItem.magicalDR; if (offHandItem.saveBonus) effective.save += offHandItem.saveBonus; if (offHandItem.save) effective.save += offHandItem.save; }
        if (accessoryItem) { if (accessoryItem.ac) effective.ac += accessoryItem.ac; if (accessoryItem.hp) effective.maxHp += accessoryItem.hp; if (accessoryItem.drBonus) { effective.physicalDR += accessoryItem.drBonus; effective.magicalDR += accessoryItem.drBonus; } if (accessoryItem.physicalDR) effective.physicalDR += accessoryItem.physicalDR; if (accessoryItem.magicalDR) effective.magicalDR += accessoryItem.magicalDR; if (accessoryItem.saveBonus) effective.save += accessoryItem.saveBonus; if (accessoryItem.save) effective.save += accessoryItem.save; accessoryBonus.hit += accessoryItem.plusToHit || 0; accessoryBonus.damage += accessoryItem.plusToDamage || 0; }
        if (mainHandItem && mainHandItem.category === 'weapon') { effective.mainHand.toHitBonus = mainHandItem.plusToHit || 0; const totalDamageBonusMH = (mainHandItem.plusToDamage || 0) + accessoryBonus.damage; effective.mainHand.damageString = `${mainHandItem.damageDice || '1d4'}${totalDamageBonusMH >= 0 ? '+' : ''}${totalDamageBonusMH}`; effective.mainHand.damageType = mainHandItem.damageType || 'bludgeoning'; if (mainHandItem.grantsExtraAttack) { effective.mainHand.numAttacks += 1; } } else { effective.mainHand.toHitBonus = 0; const totalDamageBonusMH = 0 + accessoryBonus.damage; effective.mainHand.damageString = `1d4${totalDamageBonusMH >= 0 ? '+' : ''}${totalDamageBonusMH}`; effective.mainHand.damageType = 'bludgeoning'; } effective.mainHand.toHitBonus += accessoryBonus.hit;
        if (isTwoHanding || isShielding) { effective.offHand.numAttacks = 0; effective.offHand.toHitBonus = 0; effective.offHand.damageString = "N/A"; effective.offHand.damageType = "N/A"; } else if (offHandItem && offHandItem.category === 'weapon') { effective.offHand.numAttacks = baseStats.attacksPerRound?.offHand || 0; if (effective.offHand.numAttacks > 0) { effective.offHand.toHitBonus = offHandItem.plusToHit || 0; const totalDamageBonusOH = (offHandItem.plusToDamage || 0) + accessoryBonus.damage; effective.offHand.damageString = `${offHandItem.damageDice || '1d4'}${totalDamageBonusOH >= 0 ? '+' : ''}${totalDamageBonusOH}`; effective.offHand.damageType = offHandItem.damageType || 'bludgeoning'; if (offHandItem.grantsExtraAttack) { effective.offHand.numAttacks += 1; } } else { effective.offHand.numAttacks = 0; effective.offHand.toHitBonus = 0; effective.offHand.damageString = "N/A"; effective.offHand.damageType = "N/A"; } } else { if (effective.offHand.numAttacks > 0) { effective.offHand.toHitBonus = 0; const totalDamageBonusOH = 0 + accessoryBonus.damage; effective.offHand.damageString = `1d4${totalDamageBonusOH >= 0 ? '+' : ''}${totalDamageBonusOH}`; effective.offHand.damageType = 'bludgeoning'; } else { effective.offHand.toHitBonus = 0; effective.offHand.damageString = "N/A"; effective.offHand.damageType = "N/A"; } } if (effective.offHand.numAttacks > 0) { effective.offHand.toHitBonus += accessoryBonus.hit; }
        effective.physicalDR = Math.max(0, effective.physicalDR); effective.magicalDR = Math.max(0, effective.magicalDR); effective.save = Math.max(0, effective.save); effective.mainHand.numAttacks = Math.max(0, effective.mainHand.numAttacks); effective.offHand.numAttacks = Math.max(0, effective.offHand.numAttacks);
        debugLog(`[calculateStats] Effective Stats: AC=${effective.ac} HP=${effective.maxHp} PhysDR=${effective.physicalDR} MagDR=${effective.magicalDR} Save=${effective.save}`); debugLog(`[calculateStats] MH: ${effective.mainHand.numAttacks}x Hit+${effective.mainHand.toHitBonus} Dmg:${effective.mainHand.damageString} Type:${effective.mainHand.damageType}`); debugLog(`[calculateStats] OH: ${effective.offHand.numAttacks}x Hit+${effective.offHand.toHitBonus} Dmg:${effective.offHand.damageString} Type:${effective.offHand.damageType}`);
        return effective;
     }

    // --- Inventory Management ---
    // openInventory, renderInventoryUI, Drag/Drop handlers remain the same
    // ... (Include inventory function definitions here) ...
     function openInventory() { /* ... code ... */
        const uid = auth.currentUser?.uid; if (!uid || !selectedCharacter) return; database.ref(`players/${uid}/${selectedCharacter}/inventory`).once('value').then(snapshot => { const inventory = snapshot.val(); if (inventory) { renderInventoryUI(inventory); } else { debugLog("No inventory found for character."); renderInventoryUI({ equipment: {}, bag: {} }); } document.getElementById('inventory-card').classList.remove('hidden'); }).catch(error => console.error("Error fetching inventory:", error));
     }
     function renderInventoryUI(inventory) { /* ... code ... */
         const equipmentMapping = {"mainHand":"slot-main-hand","offHand":"slot-off-hand","armor":"slot-armor","accessory":"slot-accessory"}; const equipmentSlots=inventory.equipment||{}; const itemFetches = []; const slotElements = {};
         for(let slot in equipmentMapping){const elemId=equipmentMapping[slot];const elem=document.getElementById(elemId); if(!elem) continue; elem.innerHTML="Empty"; elem.onclick=null; elem.setAttribute("draggable","true"); elem.dataset.slot=slot; elem.dataset.type="equipment"; elem.replaceWith(elem.cloneNode(true)); /* Clear old listeners */ const newElem=document.getElementById(elemId); newElem.addEventListener("dragstart",handleDragStart); newElem.addEventListener("dragover",handleDragOver); newElem.addEventListener("drop",handleDrop); newElem.addEventListener("dragend",handleDragEnd); newElem.addEventListener("dragleave",handleDragLeave); slotElements[elemId]=newElem; const slotData=equipmentSlots[slot]; if(slotData?.itemId){itemFetches.push(database.ref(`items/${slotData.itemId}`).once('value').then(s=>({elemId:elemId,item:s.val()})));}}
         const bagSlots=inventory.bag||{}; const bagGrid=document.querySelector('.bag-grid'); bagGrid.querySelectorAll('.bag-slot').forEach((bagElem,idx)=>{const slotKey=`slot${idx+1}`; bagElem.innerHTML="Empty"; bagElem.onclick=null; bagElem.setAttribute("draggable","true"); bagElem.dataset.slot=slotKey; bagElem.dataset.type="bag"; bagElem.replaceWith(bagElem.cloneNode(true)); const newElem=document.getElementById(`bag-slot${idx+1}`); if(newElem){ newElem.addEventListener("dragstart",handleDragStart); newElem.addEventListener("dragover",handleDragOver); newElem.addEventListener("drop",handleDrop); newElem.addEventListener("dragend",handleDragEnd); newElem.addEventListener("dragleave",handleDragLeave); slotElements[`bag-slot${idx+1}`]=newElem; const bagData=bagSlots[slotKey]; if(bagData?.itemId){itemFetches.push(database.ref(`items/${bagData.itemId}`).once('value').then(s=>({elemId:`bag-slot${idx+1}`,item:s.val()})));}}});
         Promise.all(itemFetches).then(results=>{results.forEach(res=>{if(res.item && slotElements[res.elemId]){const elem=slotElements[res.elemId]; elem.innerHTML=`<img src="${res.item.imageUrl||'https://via.placeholder.com/40'}" alt="${res.item.name}"/><span style="font-size:0.8em;">${res.item.name}</span>`; elem.onclick=()=>showItemCard(res.item);}});}).catch(err=>console.error("Error rendering items:",err));
     }
     function handleDragStart(e){ /* ... */ const data={fromSlot:e.currentTarget.dataset.slot,fromType:e.currentTarget.dataset.type}; e.dataTransfer.setData("text/plain",JSON.stringify(data)); e.currentTarget.classList.add("dragging"); e.dataTransfer.effectAllowed="move"; }
     function handleDragOver(e){ /* ... */ e.preventDefault(); e.dataTransfer.dropEffect="move"; e.currentTarget.classList.add("drag-hover"); }
     function handleDragEnd(e){ /* ... */ document.querySelectorAll(".drag-hover,.dragging").forEach(el=>{el.classList.remove("drag-hover"); el.classList.remove("dragging");}); }
     function handleDragLeave(e){ /* ... */ e.currentTarget.classList.remove("drag-hover"); }
     async function handleDrop(e) { /* ... logic remains the same ... */
         e.preventDefault(); const target=e.currentTarget; const toSlot=target.dataset.slot; const toType=target.dataset.type; const dataStr=e.dataTransfer.getData("text/plain"); if(!dataStr)return; const droppedData=JSON.parse(dataStr); if(!droppedData?.fromSlot||!droppedData.fromType)return; if(droppedData.fromSlot===toSlot&&droppedData.fromType===toType)return;
         const uid=auth.currentUser?.uid; if(!uid||!selectedCharacter)return; const playerSnap=await database.ref(`players/${uid}/${selectedCharacter}`).once('value'); const playerInv=playerSnap.val()?.inventory; if(!playerInv)return; const fromData=getItemFromInventory(playerInv,droppedData.fromType,droppedData.fromSlot); const toData=getItemFromInventory(playerInv,toType,toSlot);
         if(toType==="equipment"&&fromData?.itemId){const itemSnap=await database.ref(`items/${fromData.itemId}`).once('value'); const item=itemSnap.val(); if(!item||!isValidEquipSlot(item.category,toSlot)){alert("⚠️ Cannot equip that here."); return;}}
         setItemInInventory(playerInv,droppedData.fromType,droppedData.fromSlot,toData||null); setItemInInventory(playerInv,toType,toSlot,fromData||null);
         await database.ref(`players/${uid}/${selectedCharacter}/inventory`).set(playerInv); renderInventoryUI(playerInv); // Re-render
     }
     function getItemFromInventory(inventory,type,slot){ /* ... */ if(type==="equipment"){return inventory.equipment?.[slot]||null;}else{return inventory.bag?.[slot]||null;} }
     function setItemInInventory(inventory,type,slot,itemData){ /* ... */ if(type==="equipment"){if(!inventory.equipment)inventory.equipment={}; inventory.equipment[slot]=itemData;}else{if(!inventory.bag)inventory.bag={}; inventory.bag[slot]=itemData;} }
     function isValidEquipSlot(category,slot){ /* ... */ const valid={weapon:["mainHand","offHand"],shield:["offHand"],armor:["armor"],accessory:["accessory"]}; return valid[category]?.includes(slot); }


    // --- Card Display ---
    // showCharacterCard, showCreatureCard, showItemCard remain the same
    // ... (Include function definitions here) ...
    function showCharacterCard() { /* ... logic ... */
        const uid=auth.currentUser?.uid; if(!uid||!selectedCharacter)return; database.ref(`players/${uid}/${selectedCharacter}`).once('value').then(snapshot=>{const charData=snapshot.val(); if(charData){document.getElementById('character-card-image').src=`/images/classes/${charData.class.toLowerCase()}.png`; document.getElementById('character-card-name').textContent=charData.name; document.getElementById('character-card-class').textContent=charData.class; document.getElementById('character-card-hp').textContent=charData.stats?.hp||0; document.getElementById('character-card-ac').textContent=charData.stats?.ac||0; document.getElementById('character-card-save').textContent=charData.stats?.save||0; document.getElementById('character-card-physdr').textContent=charData.stats?.physicalDR||0; document.getElementById('character-card-magdr').textContent=charData.stats?.magicalDR||0; document.getElementById('character-card-mainAttacks').textContent=charData.stats?.attacksPerRound?.mainHand||0; document.getElementById('character-card-offAttacks').textContent=charData.stats?.attacksPerRound?.offHand||0; const currentLevel=charData.stats?.level||1; const currentXP=charData.stats?.xp||0; const nextLevel=currentLevel+1; const xpRequired=globalLevelTable?.[String(nextLevel)]?.xpRequired??"Max"; document.getElementById('character-card-level').textContent=currentLevel; document.getElementById('character-card-xp').textContent=currentXP; document.getElementById('character-card-xpRequired').textContent=xpRequired; document.getElementById('character-card-overlay').classList.remove('hidden');}}).catch(error=>console.error("Error fetching character data:",error));
    }
    function showCreatureCard(spawn) { /* ... logic ... */
        currentSpawnForBattle=spawn; const card=document.getElementById('creature-card'); card.classList.remove('hidden'); // Show overlay
        document.getElementById('card-image').src=(spawn.imageUrl&&spawn.imageUrl.trim()!=="")?spawn.imageUrl:"https://via.placeholder.com/100"; const borderInfo=getBorderColor(spawn.creatureRarity,spawn.stats?.exp); const innerCard=card.querySelector('.creature-card'); innerCard.style.border=borderInfo.thickness+"px solid "+borderInfo.color; innerCard.style.boxShadow="0 0 20px "+borderInfo.color; document.getElementById('card-name').textContent=spawn.creatureName||spawn.type; document.getElementById('card-cr').textContent=spawn.stats?.cr??"-"; document.getElementById('card-exp').textContent=spawn.stats?.exp??"-";
    }
    function showItemCard(item) { /* ... logic ... */
        const card=document.getElementById('item-card'); document.getElementById('item-card-name').textContent=item.name; document.getElementById('item-card-image').src=item.imageUrl||"https://via.placeholder.com/80"; document.getElementById('item-card-goldValue').textContent=(item.goldValue||0)+" gold"; const hitElem=document.getElementById('item-card-hit'); const dmgElem=document.getElementById('item-card-damage'); if(item.category==="weapon"){hitElem.textContent="Hit: +"+(item.plusToHit||0); dmgElem.textContent="Damage: "+(item.damageDice||"1d4")+" +"+(item.plusToDamage||0);}else{hitElem.textContent=""; dmgElem.textContent="";}
        const abilitiesContainer=document.getElementById("item-card-specialAbilities"); abilitiesContainer.innerHTML=""; if(item.specialAbilities?.length>0){const title=document.createElement("h3"); title.textContent="Special Abilities:"; abilitiesContainer.appendChild(title); const ul=document.createElement("ul"); item.specialAbilities.forEach(ability=>{const li=document.createElement("li"); li.textContent=ability.description; ul.appendChild(li);}); abilitiesContainer.appendChild(ul);} document.getElementById("item-card-description").textContent=item.description||"";
        const borderInfo=getBorderColor(item.rarity,item.goldValue); const innerCard=card.querySelector('.item-card'); innerCard.style.border=borderInfo.thickness+"px solid "+borderInfo.color; innerCard.style.boxShadow="0 0 20px "+borderInfo.color; card.classList.remove('hidden');
    }
    function getBorderColor(rarity, exp) { /* ... logic ... */
        let color="#A9A9A9"; switch(rarity?.toLowerCase()){case"legendary":color="#8A2BE2";break;case"rare":color="#1E90FF";break;case"uncommon":color="#32CD32";break;} let thickness=4; if(exp>3000)thickness=8; else if(exp>1000)thickness=6; return{color:color,thickness:thickness};
    }


    // --- Battle UI Update ---
    // showBattleCard (latest version targeting modern-battle) remains the same
    // addCombatLogMessage defined inside showBattleCard previously, move it out
    // ... (Include the definitions for showBattleCard here) ...
    function showBattleCard(battleData) {
        const battleCard = document.getElementById("battle-card");
        if (!battleCard) { console.error("Battle card element not found!"); return; }
        battleCard.classList.remove("hidden"); // MAKE SURE IT'S SHOWN
        debugLog("[showBattleCard] Updating NEW battle display with data:", battleData);
        addCombatLogMessage("Displaying Battle State...");
        document.querySelectorAll('.combat-section.active').forEach(el => el.classList.remove('active')); // Clear previous active section highlight
        const player = battleData.player; const playerSection = document.querySelector('.player-section');
        if (player && playerSection) {
            playerSection.querySelector("#player-image").src = player.imageUrl || "/images/character-placeholder.png"; playerSection.querySelector("#player-name").textContent = player.name || "Player"; playerSection.querySelector("#player-level").textContent = player.level || 1; playerSection.querySelector("#player-class").textContent = player.class || "Class"; playerSection.querySelector("#player-current-hp").textContent = player.currentHp; playerSection.querySelector("#player-max-hp").textContent = player.maxHp; playerSection.querySelector("#player-ac").textContent = player.ac; playerSection.querySelector("#player-phys-dr").textContent = player.physicalDR; playerSection.querySelector("#player-mag-dr").textContent = player.magicalDR; playerSection.querySelector("#player-save").textContent = player.save;
            const playerHpFill = playerSection.querySelector(".player-hp-bar .hp-fill"); const playerHpPercent = player.maxHp > 0 ? (player.currentHp / player.maxHp) * 100 : 0; playerHpFill.style.width = `${Math.max(0, playerHpPercent)}%`;
            const playerStatusDiv = playerSection.querySelector(".player-status"); playerStatusDiv.innerHTML = ""; /* TODO: Render statuses */
            const ohAttackBtn = document.getElementById('action-attack-oh'); if (ohAttackBtn) ohAttackBtn.disabled = !(player.offHand?.numAttacks > 0);
        } else { console.error("[showBattleCard] Player data or player section missing!"); }
        const enemySection = document.querySelector('.enemy-section');
        if (battleData.enemies && battleData.enemies.length > 0 && enemySection) {
            enemySection.style.display = ''; // Ensure section is visible
            const enemy = battleData.enemies[0];
            enemySection.querySelector(".enemy-name").textContent = enemy.name || 'Enemy'; enemySection.querySelector(".enemy-image").src = enemy.imageUrl || "/images/enemy-placeholder.png"; enemySection.querySelector(".enemy-current-hp").textContent = enemy.currentHp; enemySection.querySelector(".enemy-max-hp").textContent = enemy.maxHp; enemySection.querySelector(".enemy-ac").textContent = enemy.ac; enemySection.querySelector(".enemy-phys-dr").textContent = enemy.physicalDR?.amount ?? 0; enemySection.querySelector(".enemy-mag-dr").textContent = enemy.magicalDR?.amount ?? 0; enemySection.querySelector(".enemy-save").textContent = enemy.save;
            const enemyHpFill = enemySection.querySelector(".enemy-hp-bar .hp-fill"); const enemyHpPercent = enemy.maxHp > 0 ? (enemy.currentHp / enemy.maxHp) * 100 : 0; enemyHpFill.style.width = `${Math.max(0, enemyHpPercent)}%`;
            const enemyStatusDiv = enemySection.querySelector(".enemy-status"); enemyStatusDiv.innerHTML = ""; /* TODO: Render statuses */
        } else { console.error("[showBattleCard] Enemies data missing or enemy section not found!"); if (enemySection) enemySection.style.display = 'none'; }
        const turnOrderBar = document.getElementById("turn-order-bar"); turnOrderBar.innerHTML = ""; let activeCombatantName = null;
        if (battleData.turnOrder && battleData.turnOrder.length > 0) {
            battleData.turnOrder.forEach((combatantName, index) => {
                const turnItem = document.createElement("span"); turnItem.classList.add("turn-item"); if (index === battleData.currentTurnIndex) { turnItem.classList.add("active"); activeCombatantName = combatantName; } turnItem.textContent = combatantName.substring(0, 10); turnOrderBar.appendChild(turnItem);
            });
            if (activeCombatantName) {
                let isPlayerActive = (battleData.player.name === activeCombatantName);
                if (isPlayerActive && playerSection) { playerSection.classList.add('active'); debugLog(`[showBattleCard] Highlighting player turn.`); }
                 else if (!isPlayerActive && enemySection) { enemySection.classList.add('active'); debugLog(`[showBattleCard] Highlighting enemy turn.`); }
                document.getElementById('action-attack-mh').disabled = !isPlayerActive; document.getElementById('action-attack-oh').disabled = !(isPlayerActive && player.offHand?.numAttacks > 0); document.getElementById('action-special').disabled = !isPlayerActive; document.getElementById('action-item').disabled = !isPlayerActive; document.getElementById('end-turn').disabled = !isPlayerActive;
            }
        } else { console.error("[showBattleCard] Turn order data missing or empty!"); }
    }


    // --- Battle Logic Helpers & Placeholders ---
    function isPlayerTurn() { /* ... logic ... */ if (!currentBattleData?.player) return false; const currentTurnName = currentBattleData.turnOrder?.[currentBattleData.currentTurnIndex]; return currentTurnName === currentBattleData.player.name; }
    function handleAiTurn() { /* ... logic ... */ if (!currentBattleData || isPlayerTurn()) return; const aiName = currentBattleData.turnOrder?.[currentBattleData.currentTurnIndex]; addCombatLogMessage(`${aiName}'s turn... (AI logic placeholder)`); debugLog(`AI Turn: ${aiName}`); setTimeout(() => { if(!currentBattleData) return; addCombatLogMessage(`${aiName} ends turn.`); currentBattleData.currentTurnIndex = (currentBattleData.currentTurnIndex + 1) % currentBattleData.turnOrder.length; showBattleCard(currentBattleData); }, 1500); }
    function handleAttackAction(slot) { /* ... logic ... */ if (!currentBattleData || !isPlayerTurn()) { addCombatLogMessage("Cannot attack now."); return; } const targetEnemy = currentBattleData.enemies?.[0]; if (!targetEnemy) { addCombatLogMessage("No target found!"); return; } const attackDetails = currentBattleData.player?.[slot]; if (!attackDetails) { addCombatLogMessage(`Invalid attack slot: ${slot}`); return; } addCombatLogMessage(`Player attacks ${targetEnemy.name} with ${slot} (${attackDetails.damageString})...`); debugLog(`Player attack intent: Slot=${slot}, Target=${targetEnemy.instanceId}`); /* TODO: Send Photon Event EV_PLAYER_ACTION */ document.getElementById('action-attack-mh').disabled=true; document.getElementById('action-attack-oh').disabled=true; /* document.getElementById('end-turn').disabled = true; */ } // Keep End Turn enabled after attack?

    // --- Battle Initiation ---
     async function handleInitiateBattle() { /* ... logic as provided previously ... */
        const initialAttackBtn = document.getElementById("attack-button"); debugLog("Initial Attack button clicked."); if(initialAttackBtn) initialAttackBtn.disabled = true; document.getElementById("creature-card").classList.add("hidden"); const creatureSpawn = currentSpawnForBattle;
        if (!creatureSpawn) { debugLog("Attack aborted: No currentSpawnForBattle.", true); alert("Error: No creature selected."); if(initialAttackBtn) initialAttackBtn.disabled = false; return; }
        const user = auth.currentUser; if (!user) { debugLog("Attack aborted: No auth user.", true); alert("Login required."); if(initialAttackBtn) initialAttackBtn.disabled = false; return; } const uid = user.uid;
        try {
            debugLog("Fetching player data, inventory, and items..."); const playerSnapshot = await database.ref(`players/${uid}`).once("value"); if (!playerSnapshot.exists()) throw new Error(`Player data not found: ${uid}`); const playerData = playerSnapshot.val(); const activeCharKey = playerData.activeCharacter; if (!activeCharKey || !playerData[activeCharKey]) throw new Error(`Active character invalid: ${uid}`); const activeCharBaseData = playerData[activeCharKey];
            const itemIdsToFetch = new Set(); const inventory = activeCharBaseData.inventory || { equipment: {}, bag: {} }; if (inventory.equipment) Object.values(inventory.equipment).forEach(equip => { if (equip?.itemId) itemIdsToFetch.add(equip.itemId); });
            const itemPromises = Array.from(itemIdsToFetch).map(itemId => database.ref(`items/${itemId}`).once('value').then(snap => ({ id: itemId, data: snap.val() }))); const itemResults = await Promise.all(itemPromises); const itemsData = itemResults.reduce((acc, res) => { if (res.data) acc[res.id] = res.data; else debugLog(`Warn: Failed fetch item: ${res.id}`, true); return acc; }, {}); debugLog(`Fetched ${Object.keys(itemsData).length} item details.`);
            const playerEffectiveStats = calculateEffectivePlayerStats(activeCharBaseData.stats, inventory.equipment, itemsData); playerEffectiveStats.name = activeCharBaseData.name; playerEffectiveStats.class = activeCharBaseData.class; playerEffectiveStats.imageUrl = `/images/classes/${activeCharBaseData.class.toLowerCase()}.png`;
            const creatureIdentifier = creatureSpawn.creatureId || creatureSpawn.creatureName?.replace(/\s+/g, '_') || 'unknown'; const roomName = "battle_" + creatureIdentifier + "_" + Date.now(); const roomOptions = { maxPlayers: 2, isOpen: true, isVisible: true }; debugLog(`Generated room name: ${roomName}`); debugLog(`Calling prepareAndJoinBattleRoom for room: ${roomName}`); const joinedRoom = await prepareAndJoinBattleRoom(roomName, roomOptions); debugLog(`Joined room: ${joinedRoom.name}`);
            debugLog("Calculating initiative..."); const playerInitiative = Math.floor(Math.random() * 20) + 1; const enemyStats = creatureSpawn.stats; const enemyInitiative = enemyStats.initiative || Math.floor(Math.random() * 20) + 1;
            const playerBattleData = { ...playerEffectiveStats, id: activeCharKey, actorNr: photonClient.myActor().actorNr, currentHp: playerEffectiveStats.maxHp, initiative: playerInitiative, statusEffects: [] };
            const enemyBattleData = { templateId: creatureSpawn.creatureId||"unknown", instanceId: `${creatureSpawn.creatureId||'enemy'}_${Date.now()}`, name: creatureSpawn.creatureName||"Creature", imageUrl: creatureSpawn.imageUrl||"/images/enemy-placeholder.png", ac: enemyStats.ac||10, maxHp: enemyStats.hp||10, currentHp: enemyStats.hp||10, physicalDR: enemyStats.physicalDR||{amount:0}, magicalDR: enemyStats.magicalDR||{amount:0}, save: enemyStats.save||0, attackBonus: enemyStats.attackBonus||0, attackDamage: enemyStats.attackDamage||"1d4+0", initiative: enemyInitiative, statusEffects: [] };
            const turnOrderNames = (playerInitiative >= enemyInitiative) ? [playerBattleData.name, enemyBattleData.name] : [enemyBattleData.name, playerBattleData.name];
            currentBattleData = { roomId: joinedRoom.name, player: playerBattleData, enemies: [enemyBattleData], turnOrder: turnOrderNames, currentTurnIndex: 0 };
            debugLog("currentBattleData created: " + JSON.stringify(currentBattleData).substring(0, 500) + "..."); // Log snippet
            // TODO: SERVER-SIDE: INITIALIZE BATTLE STATE in /activeBattles/{roomId}
            debugLog("Showing battle card UI."); addCombatLogMessage("Battle starts!"); showBattleCard(currentBattleData);
        } catch (err) { console.error("Error starting battle:", err); debugLog(`Error starting battle: ${err.message}. Stack: ${err.stack}`, true); alert("Could not start battle: " + err.message); currentBattleData = null; }
        finally { if(initialAttackBtn) initialAttackBtn.disabled = false; }
    }


    // --- Consolidated DOMContentLoaded ---
    document.addEventListener("DOMContentLoaded", function() {
        // --- Portrait & Character Card ---
        document.getElementById("portrait-container")?.addEventListener("click", showCharacterCard);
        document.getElementById("character-card-overlay")?.addEventListener("click", function(e) { if (e.target === this) this.classList.add("hidden"); });
        document.getElementById("open-inventory-button")?.addEventListener("click", openInventory);
        // --- Inventory Card ---
        document.getElementById("close-inventory-card")?.addEventListener("click", function() { document.getElementById("inventory-card").classList.add("hidden"); });
        document.getElementById("inventory-button")?.addEventListener("click", openInventory); // Bottom menu button
        // --- Item Card ---
        document.getElementById("close-item-card")?.addEventListener("click", function() { document.getElementById("item-card").classList.add("hidden"); });
        // --- Battle Card Actions ---
        document.getElementById("end-turn")?.addEventListener("click", function() {
            if (!currentBattleData) { console.error("No battle data for End Turn."); addCombatLogMessage("Error: No battle active."); return; }
            if (!isPlayerTurn()) { addCombatLogMessage("Not your turn!"); return; }
            debugLog("End Turn button clicked."); addCombatLogMessage("Player ends turn.");
            // TODO: Send 'End Turn' intent to server via Photon Event
            // TEMPORARY CLIENT-SIDE TURN CHANGE FOR TESTING:
            currentBattleData.currentTurnIndex = (currentBattleData.currentTurnIndex + 1) % currentBattleData.turnOrder.length; showBattleCard(currentBattleData); if (!isPlayerTurn()) { handleAiTurn(); }
        });
        document.getElementById('action-attack-mh')?.addEventListener('click', () => handleAttackAction('mainHand'));
        document.getElementById('action-attack-oh')?.addEventListener('click', () => handleAttackAction('offHand'));
        // Add listeners for special, item later...

        // --- Creature Card Attack Button (Initiates Battle) ---
        const initialAttackBtn = document.getElementById("attack-button");
        if (initialAttackBtn) {
            initialAttackBtn.addEventListener("click", handleInitiateBattle);
        } else {
            console.error("Initial attack button ('#attack-button') not found!");
        }

         // Add listener for creature card run button
         document.getElementById("run-button")?.addEventListener("click", () => {
             debugLog("Run button clicked.");
             document.getElementById("creature-card").classList.add("hidden");
             currentSpawnForBattle = null; // Clear selection
             addCombatLogMessage("You decided not to attack.");
         });

        debugLog("DOMContentLoaded: All initial event listeners set up.");
    }); // --- End DOMContentLoaded ---

  </script>

</body>
</html>