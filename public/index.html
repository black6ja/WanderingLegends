<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WanderingLegends</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      position: relative;
    }
    #login-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f4f4f4;
    }
    #login-container button {
      padding: 10px;
      margin: 10px;
      width: 80%;
      max-width: 300px;
      background-color: #4285F4;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 1em;
    }
    #login-container button:hover {
      background-color: #357ae8;
    }
    #login-message {
      font-size: 0.9em;
      margin-top: 10px;
    }
    #map-container {
      display: none;
      flex: 1;
    }
    #output, #queueStatus, #debugPanel {
      padding: 10px;
      background-color: #f2f2f2;
      font-size: 0.9em;
      overflow-y: auto;
      max-height: 150px;
    }
    #map {
      flex: 1;
      width: 100%;
      height: 100vh;
      min-height: 400px;
    }
    #debugPanel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #333;
      color: #fff;
      font-size: 0.8em;
      padding: 5px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="login-container">
    <h2>Login to WanderingLegends</h2>
    <button onclick="googleLogin()">Sign in with Google</button>
    <button onclick="anonymousLogin()">Continue Anonymously</button>
    <p id="login-message"></p>
  </div>

  <div id="map-container">
    <button onclick="logout()">Logout</button>
    <div id="output"></div>
    <div id="map"></div>
    <div id="queueStatus">Click a <strong>World Boss</strong> or <strong>Public Event</strong> to enter battle.</div>
  </div>

  <div id="debugPanel"></div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="photon.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    let gameShown = false;
    let spawnConfig = {};
    const database = firebase.database();
    
    async function loadSpawnData() {
      try {
        let response = await fetch("spawnData.json");
        let data = await response.json();
        data.spawnTypes.forEach(spawn => {
          spawnConfig[spawn.type] = spawn;
        });
        console.log("Loaded spawn settings:", spawnConfig);
      } catch (error) {
        console.error("Error loading spawnData.json:", error);
      }
    }

    function googleLogin() {
      const provider = new firebase.auth.GoogleAuthProvider();
      firebase.auth().signInWithRedirect(provider).catch(error => console.error("Google sign-in error:", error));
    }

    function anonymousLogin() {
      firebase.auth().signInAnonymously().catch(error => console.error("Anonymous sign-in error:", error));
    }

    firebase.auth().getRedirectResult().then(result => {
      if (result.user) console.log("getRedirectResult: User signed in.");
    }).catch(error => console.error("getRedirectResult error:", error));

    firebase.auth().onAuthStateChanged(user => {
      if (user && !gameShown) {
        gameShown = true;
        showGame();
      }
    });

    function logout() {
      firebase.auth().signOut().then(() => location.reload());
    }

    function showGame() {
      document.getElementById("login-container").style.display = "none";
      document.getElementById("map-container").style.display = "block";
      initializeGame();
    }

    async function generateSpawns(center) {
      if (!spawnConfig || Object.keys(spawnConfig).length === 0) return;
      let totalSpawns = 0;
      for (let type in spawnConfig) {
        let spawnData = spawnConfig[type];
        let count = spawnData.maxPerArea;
        for (let i = 0; i < count; i++) {
          let offset = generateRandomOffset(500);
          let newSpawn = {
            type: type,
            location: { lat: center.lat + offset.latOffset, lng: center.lng + offset.lngOffset },
            lastSpawnTime: Date.now(),
            respawnTime: spawnData.respawnTime
          };
          await database.ref("spawnPoints").push(newSpawn);
          totalSpawns++;
        }
      }
      console.log(`Generated ${totalSpawns} spawn points.`);
    }

    async function cleanupExpiredSpawns() {
      let now = Date.now();
      let spawnsRef = database.ref("spawnPoints");
      spawnsRef.once("value", snapshot => {
        snapshot.forEach(child => {
          let spawn = child.val();
          let spawnId = child.key;
          let respawnTime = spawnConfig[spawn.type]?.respawnTime || 300000;
          if (now - spawn.lastSpawnTime >= respawnTime) spawnsRef.child(spawnId).remove();
        });
      });
    }

    function getCacheDuration(spawnType) {
      return spawnConfig[spawnType]?.respawnTime || 300000;
    }

    function fetchSpawnPoints(center) {
      let now = Date.now();
      let cachedSpawns = JSON.parse(localStorage.getItem("cachedSpawns") || "{}");
      let validSpawns = Object.entries(cachedSpawns).filter(([id, spawn]) => now - spawn.lastSpawnTime < getCacheDuration(spawn.type));

      if (validSpawns.length > 0) {
        console.log("Using cached spawn points.");
        updateMapWithSpawns(validSpawns.map(([id, spawn]) => spawn));
      } else {
        console.log("Fetching new spawn points from Firebase...");
        database.ref("spawnPoints").once("value", snapshot => {
          let newSpawns = {};
          snapshot.forEach(child => {
            newSpawns[child.key] = child.val();
          });
          localStorage.setItem("cachedSpawns", JSON.stringify(newSpawns));
          updateMapWithSpawns(Object.values(newSpawns));
        });
      }
    }

    function initializeGame() {
      let map = L.map("map").setView([37.7749, -122.4194], 13);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "&copy; OpenStreetMap contributors" }).addTo(map);
      loadSpawnData();
    }

    function generateRandomOffset(meters) {
      const dLat = meters / 111300, dLng = dLat / Math.cos(map.getCenter().lat * Math.PI / 180);
      return { latOffset: (Math.random() * 2 - 1) * dLat, lngOffset: (Math.random() * 2 - 1) * dLng };
    }
  </script>
</body>
</html>
