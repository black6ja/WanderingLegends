<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Leaflet: User Location with Multiple Spawn Types</title>
  <!-- Mobile-friendly viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- MarkerCluster CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    /* Player marker (pulsing blue circle) */
    .blinking-circle {
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 255, 0.7);
      border: 2px solid white;
      border-radius: 50%;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    @media (max-width: 768px) {
      .blinking-circle {
        animation: none;
        background: rgba(0, 0, 255, 1);
      }
    }
    /* Custom spawn icons – small colored circles */
    .spawn-icon div {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .spawn-icon.creatures div { background: purple; }
    .spawn-icon.dungeons div { background: darkgray; }
    .spawn-icon.inns div { background: orange; }
    .spawn-icon.shops div { background: blue; }
    .spawn-icon.quests div { background: green; }
    .spawn-icon.keeps div { background: brown; }
    .spawn-icon.lairs div { background: black; }
    /* Public event zone styling */
    .blinking-zone {
      animation: blinkZone 2s infinite;
    }
    @keyframes blinkZone {
      0% { fill-opacity: 0.3; }
      50% { fill-opacity: 0.1; }
      100% { fill-opacity: 0.3; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>
    // --- Configuration Constants ---
    const MIN_MOVE_DISTANCE = 50;       // Only recenter if user moves >50 m after the initial fix.
    const PLAYER_RADIUS_YARDS = 250;      // Player radius: 250 yards (≈229 m).
    
    // URL to the spawn points JSON file (placed in the same directory)
    const spawnsJsonUrl = "spawnPoints.json";
    
    // --- Global Variables ---
    var lastPlayerLatLng = null;    // Last known user location.
    var spawnMarkersData = null;    // Will hold spawn data fetched from the JSON.
    var markersCluster = L.markerClusterGroup();
    var initialCentered = false;    // Ensures the first location fix forces recentering.
    
    // --- Initialize Map ---
    // Start with a default view; expect update upon geolocation.
    var map = L.map('map', {
      preferCanvas: true,
      zoomAnimation: true
    }).setView([51.505, -0.09], 15);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // --- Create Player Marker & 250-yard Radius Circle ---
    var playerMarker = L.marker([51.505, -0.09], {
      icon: L.divIcon({
        className: '',
        html: '<div class="blinking-circle"></div>',
        iconSize: [12, 12],
        iconAnchor: [6, 6]
      })
    });
    var playerRadiusCircle = L.circle([], {
      color: 'green',
      fillOpacity: 0.2,
      radius: PLAYER_RADIUS_YARDS * 0.9144
    });
    
    // --- Define Custom Spawn Icons for Different Types ---
    var spawnIcons = {
      creatures: L.divIcon({
        className: 'spawn-icon creatures',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      dungeons: L.divIcon({
        className: 'spawn-icon dungeons',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      inns: L.divIcon({
        className: 'spawn-icon inns',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      shops: L.divIcon({
        className: 'spawn-icon shops',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      quests: L.divIcon({
        className: 'spawn-icon quests',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      keeps: L.divIcon({
        className: 'spawn-icon keeps',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      }),
      lairs: L.divIcon({
        className: 'spawn-icon lairs',
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      })
    };
    
    // --- Function: Create Public Event Zone Overlay ---
    function createPublicEventZone(spawn) {
      // Expect spawn.zone to include: radius (meters), color, fillOpacity, blinking (boolean)
      return L.circle([spawn.lat, spawn.lng], {
        radius: spawn.zone.radius,
        color: spawn.zone.color,
        weight: 2,
        fillColor: spawn.zone.color,
        fillOpacity: spawn.zone.fillOpacity,
        className: spawn.zone.blinking ? 'blinking-zone' : ''
      });
    }
    
    // --- Function: Update Visible Spawn Markers & Zones ---
    function updateVisibleSpawnSpawns() {
      markersCluster.clearLayers();
      if (!spawnMarkersData) return;
      var currentBounds = map.getBounds();
      spawnMarkersData.forEach(function(spawn, index) {
        var pt = L.latLng(spawn.lat, spawn.lng);
        if (spawn.type === "publicEvent") {
          // For public events, add zone overlay if it intersects the current bounds.
          var zone = createPublicEventZone(spawn);
          if (currentBounds.intersects(zone.getBounds())) {
            if (!map.hasLayer(zone)) {
              zone.addTo(map);
            }
          }
        } else {
          // For point spawns, add marker if within current bounds.
          if (currentBounds.contains(pt)) {
            var icon = spawnIcons[spawn.type] || spawnIcons.creatures;
            var marker = L.marker(pt, { icon: icon }).bindPopup("Spawn " + (index + 1) + (spawn.subtype ? " (" + spawn.subtype + ")" : ""));
            markersCluster.addLayer(marker);
          }
        }
      });
      if (!map.hasLayer(markersCluster)) {
        map.addLayer(markersCluster);
      }
    }
    
    // --- Geolocation Callback ---
    function onLocationFound(e) {
      var userLatLng = e.latlng;
      
      // Force instant recenter on the first location fix.
      if (!initialCentered) {
        initialCentered = true;
        map.setView(userLatLng, 16, { animate: false });
        // Once we have the user's location, fetch spawn data from spawnPoints.json.
        fetch(spawnsJsonUrl)
          .then(function(response) { return response.json(); })
          .then(function(data) {
            // Expect the JSON file to have a property "spawns" that is an array.
            spawnMarkersData = data.spawns;
            updateVisibleSpawnSpawns();
          })
          .catch(function(err) { console.error("Error loading spawn data:", err); });
      } else if (lastPlayerLatLng) {
        var dist = map.distance(lastPlayerLatLng, userLatLng);
        if (dist >= MIN_MOVE_DISTANCE) {
          map.setView(userLatLng, 16, { animate: false });
        }
      }
      lastPlayerLatLng = userLatLng;
      
      if (!map.hasLayer(playerMarker)) {
        playerMarker.addTo(map);
        playerRadiusCircle.addTo(map);
      }
      playerMarker.setLatLng(userLatLng);
      playerRadiusCircle.setLatLng(userLatLng).setRadius(PLAYER_RADIUS_YARDS * 0.9144);
      
      updateVisibleSpawnSpawns();
    }
    
    function onLocationError(e) {
      alert("Geolocation error: " + e.message);
    }
    
    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);
    
    // Start watching the user's location.
    map.locate({ setView: false, watch: true, maxZoom: 16 });
    
    // Update spawn markers when the map moves or zooms.
    map.on('moveend zoomend', updateVisibleSpawnSpawns);
  </script>
</body>
</html>
