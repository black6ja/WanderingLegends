<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Leaflet: Dynamic Spawn Types</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }

    /* Blinking Player Marker */
    .blinking-circle {
      width: 15px;
      height: 15px;
      background: rgba(0, 0, 255, 0.8);
      border: 2px solid white;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Blinking Zone for Public Event */
    .blinking-zone {
      animation: blinkZone 2s infinite;
    }
    @keyframes blinkZone {
      0% { fill-opacity: 0.3; }
      50% { fill-opacity: 0.1; }
      100% { fill-opacity: 0.3; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

  <script>
    const spawnDataUrl = "https://raw.githubusercontent.com/black6ja/WanderingLegends/main/spawnData.json";

    var lastPlayerLatLng = null;
    var spawnTypes = null;
    var markersCluster = L.markerClusterGroup();
    var initialCentered = false;
    var dynamicSpawnPoints = [];
    var forcedPublicEvent = null;

    var map = L.map('map', { preferCanvas: true, zoomAnimation: true }).setView([51.505, -0.09], 15);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Blinking Player Marker
    var playerMarker = L.marker([51.505, -0.09], {
      icon: L.divIcon({ className: '', html: '<div class="blinking-circle"></div>', iconSize: [15, 15], iconAnchor: [7, 7] })
    });

    // Player Radius (soft blue circle)
    var playerRadiusCircle = L.circle([0, 0], {
      color: 'blue',
      fillColor: 'rgba(0, 0, 255, 0.3)',
      fillOpacity: 0.3,
      radius: 229
    });

    // Generate an irregular polygon around a center point
    function generateIrregularPolygon(center, baseRadius) {
      var numPoints = 8;
      var points = [];
      for (var i = 0; i < numPoints; i++) {
        var angle = (2 * Math.PI / numPoints) * i;
        var factor = 0.7 + Math.random() * 0.6; // random factor between 0.7 and 1.3
        var r = baseRadius * factor;
        var latOffset = (r * Math.cos(angle)) / 111300;
        var lngOffset = (r * Math.sin(angle)) / (111300 * Math.cos(center.lat * Math.PI / 180));
        points.push([center.lat + latOffset, center.lng + lngOffset]);
      }
      return points;
    }

    // Force a Public Event near the player's starting location
    function createForcedPublicEvent(userLatLng) {
      if (!forcedPublicEvent) {
        let offsetLat = userLatLng.lat + (Math.random() * 0.002 - 0.001);
        let offsetLng = userLatLng.lng + (Math.random() * 0.002 - 0.001);
        forcedPublicEvent = {
          lat: offsetLat,
          lng: offsetLng,
          radius: 300 // Larger area for public event
        };
      }
    }

    function updateVisibleSpawns() {
      markersCluster.clearLayers();
      var bounds = map.getBounds();

      // Always add the forced Public Event
      if (forcedPublicEvent) {
        var centerPt = L.latLng(forcedPublicEvent.lat, forcedPublicEvent.lng);
        var polygonCoords = generateIrregularPolygon(centerPt, forcedPublicEvent.radius);
        L.polygon(polygonCoords, {
          color: "red",
          fillColor: "red",
          fillOpacity: 0.3,
          weight: 2,
          className: "blinking-zone"
        }).addTo(map).bindPopup("Forced Public Event Zone");
      }

      dynamicSpawnPoints.forEach((spawn) => {
        var pt = L.latLng(spawn.lat, spawn.lng);
        if (bounds.contains(pt)) {
          var marker = L.circleMarker(pt, {
            color: getSpawnColor(spawn.type),
            fillColor: getSpawnColor(spawn.type),
            fillOpacity: 0.7,
            radius: 7
          }).bindPopup(`Spawn: ${spawn.type}`);
          markersCluster.addLayer(marker);
        }
      });

      if (!map.hasLayer(markersCluster)) map.addLayer(markersCluster);
    }

    function getSpawnColor(type) {
      const colors = {
        "creatures": "purple",
        "dungeons": "gray",
        "inns": "orange",
        "shops": "blue",
        "quests": "green",
        "keeps": "brown",
        "lairs": "black"
      };
      return colors[type] || "red";
    }

    function onLocationFound(e) {
      var userLatLng = e.latlng;
      lastPlayerLatLng = userLatLng;

      if (!initialCentered) {
        initialCentered = true;
        map.setView(userLatLng, 16, { animate: false });

        createForcedPublicEvent(userLatLng); // Hardcode a public event near the start

        fetch(spawnDataUrl)
          .then(resp => {
            if (!resp.ok) throw new Error(`HTTP error! Status: ${resp.status}`);
            return resp.json();
          })
          .then(data => {
            spawnTypes = data.spawnTypes || [];
            updateVisibleSpawns();
          })
          .catch(err => console.error("Error loading spawn data:", err));
      }

      if (!map.hasLayer(playerMarker)) {
        playerMarker.addTo(map);
        playerRadiusCircle.addTo(map);
      }
      playerMarker.setLatLng(userLatLng);
      playerRadiusCircle.setLatLng(userLatLng);
      updateVisibleSpawns();
    }

    map.on('locationfound', onLocationFound);
    map.locate({ setView: false, watch: true, maxZoom: 16 });
    map.on('moveend zoomend', updateVisibleSpawns);
  </script>
</body>
</html>
