<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Leaflet: Dynamic Spawn Types</title>
  <!-- Mobile-friendly viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- MarkerCluster CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    /* Player marker (pulsing circle) */
    .blinking-circle {
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 255, 0.7);
      border: 2px solid white;
      border-radius: 50%;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    @media (max-width: 768px) {
      .blinking-circle {
        animation: none;
        background: rgba(0, 0, 255, 1);
      }
    }
    /* Various spawn icons - small colored circles */
    .spawn-icon div {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    /* We'll assign color classes dynamically in code if we want, or define them if you prefer. */
    .spawn-icon.creatures div { background: purple; }
    .spawn-icon.dungeons div { background: darkgray; }
    .spawn-icon.inns div { background: orange; }
    .spawn-icon.shops div { background: blue; }
    .spawn-icon.quests div { background: green; }
    .spawn-icon.keeps div { background: brown; }
    .spawn-icon.lairs div { background: black; }
    /* Public event zone blink */
    .blinking-zone {
      animation: blinkZone 2s infinite;
    }
    @keyframes blinkZone {
      0% { fill-opacity: 0.3; }
      50% { fill-opacity: 0.1; }
      100% { fill-opacity: 0.3; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>
    // --- Configuration Constants ---
    const MIN_MOVE_DISTANCE = 50;       // Only recenter if user moves >50 m after first fix.
    const PLAYER_RADIUS_YARDS = 250;    // 250 yards ~229 m.
    const RING_WIDTH_YARDS = 500;       // Each ring is 500 yards wide.
    const RING_WIDTH = RING_WIDTH_YARDS * 0.9144; // in meters
    const MAX_SPAWN_RADIUS_YARDS = 1500; // Example: 3 rings, up to 1500 yards away from user.
    const MAX_SPAWN_RADIUS = MAX_SPAWN_RADIUS_YARDS * 0.9144; // in meters
    
    // URL to your spawn data JSON file
    const spawnDataUrl = "spawnData.json";

    // --- Global Variables ---
    var lastPlayerLatLng = null;
    var spawnTypes = null;        // Will hold spawn type definitions from JSON
    var markersCluster = L.markerClusterGroup();
    var initialCentered = false;

    // We'll store the final spawn points here
    var dynamicSpawnPoints = [];
    
    // --- Initialize Map ---
    var map = L.map('map', {
      preferCanvas: true,
      zoomAnimation: true
    }).setView([51.505, -0.09], 15);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Player marker & 250-yard circle
    var playerMarker = L.marker([51.505, -0.09], {
      icon: L.divIcon({
        className: '',
        html: '<div class="blinking-circle"></div>',
        iconSize: [12, 12],
        iconAnchor: [6, 6]
      })
    });
    var playerRadiusCircle = L.circle([], {
      color: 'green',
      fillOpacity: 0.2,
      radius: PLAYER_RADIUS_YARDS * 0.9144
    });

    // Utility: pick a spawn type (and possibly subType) from the spawnData, weighting by spawnRate
    function pickSpawnType() {
      if (!spawnTypes) return null;
      // Weighted random by spawnRate
      // 1) sum all spawnRates
      var totalRate = spawnTypes.reduce((acc, st) => acc + (st.spawnRate || 0), 0);
      var rnd = Math.random() * totalRate;
      var cumulative = 0;
      for (var i = 0; i < spawnTypes.length; i++) {
        cumulative += spawnTypes[i].spawnRate || 0;
        if (rnd <= cumulative) {
          return spawnTypes[i];
        }
      }
      return spawnTypes[spawnTypes.length - 1];
    }

    // If a spawn type has subTypes, pick one
    function pickSubType(spawnType) {
      if (!spawnType.subTypes) return null;
      // Weighted random among subTypes
      var totalSubRate = spawnType.subTypes.reduce((acc, st) => acc + (st.spawnRate || 0), 0);
      var rnd = Math.random() * totalSubRate;
      var cumulative = 0;
      for (var i = 0; i < spawnType.subTypes.length; i++) {
        cumulative += spawnType.subTypes[i].spawnRate || 0;
        if (rnd <= cumulative) {
          return spawnType.subTypes[i].name;
        }
      }
      return spawnType.subTypes[spawnType.subTypes.length - 1].name;
    }

    // Create a circle for public events
    function createPublicEventZone(spawn) {
      return L.circle([spawn.lat, spawn.lng], {
        radius: spawn.zone.radius,
        color: spawn.zone.color,
        weight: 2,
        fillColor: spawn.zone.color,
        fillOpacity: spawn.zone.fillOpacity,
        className: spawn.zone.blinking ? 'blinking-zone' : ''
      });
    }

    // Create a DivIcon for a given spawn type name
    function getSpawnIcon(type) {
      // We can define classes for each type
      return L.divIcon({
        className: 'spawn-icon ' + type,
        html: '<div></div>',
        iconSize: [10, 10],
        iconAnchor: [5, 5]
      });
    }

    // Generate dynamic spawn points in rings of 500 yards up to MAX_SPAWN_RADIUS
    // Each ring: 3-5 spawns
    function generateDynamicSpawns(center) {
      dynamicSpawnPoints = []; // reset
      var rings = Math.floor(MAX_SPAWN_RADIUS / RING_WIDTH);
      for (var i = 0; i < rings; i++) {
        var numPoints = Math.floor(Math.random() * 3) + 3; // 3-5 spawns per ring
        var innerRadius = i * RING_WIDTH;
        var outerRadius = (i + 1) * RING_WIDTH;
        for (var j = 0; j < numPoints; j++) {
          // choose random distance between innerRadius & outerRadius
          var r = innerRadius + Math.random() * (outerRadius - innerRadius);
          var angle = Math.random() * 2 * Math.PI;
          var dLat = r / 111300 * Math.cos(angle);
          var dLng = r / (111300 * Math.cos(center.lat * Math.PI / 180)) * Math.sin(angle);
          var lat = center.lat + dLat;
          var lng = center.lng + dLng;

          // pick spawn type
          var st = pickSpawnType();
          if (!st) continue;

          // if it's publicEvent => zone spawn
          if (st.type === "publicEvent" && st.zone) {
            dynamicSpawnPoints.push({
              type: "publicEvent",
              lat: lat,
              lng: lng,
              zone: st.zone,
              // spawnRate, etc.
            });
          } else {
            // normal point spawn
            var sub = pickSubType(st) || null;
            dynamicSpawnPoints.push({
              type: st.type,
              subtype: sub,
              lat: lat,
              lng: lng
            });
          }
        }
      }
    }

    // Update the map with any dynamic spawn points that fall within the current map bounds
    function updateVisibleSpawns() {
      markersCluster.clearLayers();
      if (!dynamicSpawnPoints.length) return;

      var bounds = map.getBounds();
      dynamicSpawnPoints.forEach(function(spawn, index) {
        var pt = L.latLng(spawn.lat, spawn.lng);
        if (spawn.type === "publicEvent") {
          // zone-based
          var zone = createPublicEventZone(spawn);
          if (bounds.intersects(zone.getBounds())) {
            zone.addTo(map);
          }
        } else {
          // point-based
          if (bounds.contains(pt)) {
            var icon = getSpawnIcon(spawn.type);
            var label = "Spawn " + (index + 1) + (spawn.subtype ? " (" + spawn.subtype + ")" : "");
            var marker = L.marker(pt, { icon: icon }).bindPopup(label);
            markersCluster.addLayer(marker);
          }
        }
      });
      if (!map.hasLayer(markersCluster)) {
        map.addLayer(markersCluster);
      }
    }

    // Geolocation found
    function onLocationFound(e) {
      var userLatLng = e.latlng;

      if (!initialCentered) {
        initialCentered = true;
        map.setView(userLatLng, 16, { animate: false });

        // fetch spawnData.json, parse spawn types
        fetch(spawnDataUrl)
          .then(resp => resp.json())
          .then(data => {
            spawnTypes = data.spawnTypes || [];
            // once we have spawn types, generate dynamic spawns
            generateDynamicSpawns(userLatLng);
            updateVisibleSpawns();
          })
          .catch(err => console.error("Error loading spawn data:", err));

      } else if (lastPlayerLatLng) {
        var dist = map.distance(lastPlayerLatLng, userLatLng);
        if (dist >= MIN_MOVE_DISTANCE) {
          map.setView(userLatLng, 16, { animate: false });
        }
      }
      lastPlayerLatLng = userLatLng;

      // add marker + circle if not present
      if (!map.hasLayer(playerMarker)) {
        playerMarker.addTo(map);
        playerRadiusCircle.addTo(map);
      }
      playerMarker.setLatLng(userLatLng);
      playerRadiusCircle.setLatLng(userLatLng);

      updateVisibleSpawns();
    }

    function onLocationError(e) {
      alert("Geolocation error: " + e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    // Start watching user location
    map.locate({ setView: false, watch: true, maxZoom: 16 });

    // On map move/zoom, re-check spawns
    map.on('moveend zoomend', updateVisibleSpawns);
  </script>
</body>
</html>
